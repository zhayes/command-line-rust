<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops"><head><title>Shave and a Haircut</title><link href="epub.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e80a1ec8-ed8e-40f7-ba3d-26a647960341" name="Adept.expected.resource"/></head><body data-type="book"><section data-pdf-bookmark="Chapter 8. Shave and a Haircut" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch08">
<h1><span class="label">Chapter 8. </span>Shave and a Haircut</h1>

<blockquote>
<p>
I’m a mess / Since you cut me out / But Chucky’s arm keeps me company
</p>
<p data-type="attribution">
They Might Be Giants, “Cyclops Rock” (2001)
</p>
</blockquote>

<p>For the next challenge program, you will create a Rust version of <code>cut</code>, which will excise text from a file or <code>STDIN</code>.<a data-primary="cut utility" data-type="indexterm" id="ix_cut"/>
The selected text could be some range of bytes or characters or might be fields denoted by a delimiter like a comma or tab that creates field boundaries.<a data-primary="ranges" data-secondary="selected text for cutting" data-type="indexterm" id="id963"/>
You learned how to select a contiguous range of characters or bytes in <a data-type="xref" href="ch04.html#ch04">Chapter 4</a>, while working on the <code>headr</code> program, but this challenge goes further as the selections may be noncontiguous and in any order.
For example, the selection <code>3,1,5-7</code> should cause the challenge program to print the third, first, and fifth through seventh bytes, characters, or fields, in that order.
The challenge program will capture the spirit of the original but will not strive for complete fidelity, as I will suggest a few changes that I feel are improvements.</p>

<p>In this chapter, you will learn how to do the following:</p>

<ul>
<li>
<p>Read and write a delimited text file using the <code>csv</code> crate</p>
</li>
<li>
<p>Deference a value using <code>*</code></p>
</li>
<li>
<p>Use <code>Iterator::flatten</code> to remove nested structures from iterators</p>
</li>
<li>
<p>Use <code>Iterator::flat_map</code> to combine <code>Iterator::map</code> and <code>Iterator::flatten</code></p>
</li>
</ul>






<section class="pagebreak-before less_space" data-pdf-bookmark="How cut Works" data-type="sect1"><div class="sect1" id="id76">
<h1>How cut Works</h1>

<p>I will start<a data-primary="cut utility" data-secondary="how it works" data-type="indexterm" id="ix_cuthow"/><a data-primary="BSD version" data-secondary="cut utility" data-type="indexterm" id="id964"/> by reviewing the portion of the BSD <code>cut</code> manual page that describes the features of the program you will write:</p>

<pre data-type="programlisting">CUT(1)                    BSD General Commands Manual                   CUT(1)

NAME
     cut -- cut out selected portions of each line of a file

SYNOPSIS
     cut -b list [-n] [file ...]
     cut -c list [file ...]
     cut -f list [-d delim] [-s] [file ...]

DESCRIPTION
     The cut utility cuts out selected portions of each line (as specified by
     list) from each file and writes them to the standard output.  If no file
     arguments are specified, or a file argument is a single dash ('-'), cut
     reads from the standard input.  The items specified by list can be in
     terms of column position or in terms of fields delimited by a special
     character.  Column numbering starts from 1.

     The list option argument is a comma or whitespace separated set of num-
     bers and/or number ranges.  Number ranges consist of a number, a dash
     ('-'), and a second number and select the fields or columns from the
     first number to the second, inclusive.  Numbers or number ranges may be
     preceded by a dash, which selects all fields or columns from 1 to the
     last number.  Numbers or number ranges may be followed by a dash, which
     selects all fields or columns from the last number to the end of the
     line.  Numbers and number ranges may be repeated, overlapping, and in any
     order.  If a field or column is specified multiple times, it will appear
     only once in the output.  It is not an error to select fields or columns
     not present in the input line.</pre>

<p>The original tool offers quite a few options, but the challenge program will implement only the following:</p>

<pre data-type="programlisting">     -b list
             The list specifies byte positions.

     -c list
             The list specifies character positions.

     -d delim
             Use delim as the field delimiter character instead of the tab
             character.

     -f list
             The list specifies fields, separated in the input by the field
             delimiter character (see the -d option.)  Output fields are sepa-
             rated by a single occurrence of the field delimiter character.</pre>

<p>As usual, the GNU version<a data-primary="GNU version" data-secondary="cut utility" data-type="indexterm" id="id965"/> offers both short and long flags for these options:</p>

<pre data-type="programlisting">NAME
       cut - remove sections from each line of files

SYNOPSIS
       cut OPTION... [FILE]...

DESCRIPTION
       Print selected parts of lines from each FILE to standard output.

       Mandatory  arguments  to  long  options are mandatory for short options
       too.

       -b, --bytes=LIST
              select only these bytes

       -c, --characters=LIST
              select only these characters

       -d, --delimiter=DELIM
              use DELIM instead of TAB for field delimiter

       -f, --fields=LIST
              select only these fields;  also print any line that contains  no
              delimiter character, unless the -s option is specified</pre>

<p>Both tools implement the <a data-primary="ranges" data-secondary="closed or partially defined in cut utilities" data-type="indexterm" id="id966"/>selection ranges in similar ways, where numbers can be selected individually, in closed ranges like <code>1-3</code>, or in partially defined ranges like 
<span class="keep-together"><code>-3</code></span> to indicate 1 through 3 or <code>5-</code> to indicate 5 to the end, but the challenge program will support only closed ranges.
I’ll use some of the files found in the book’s <em>08_cutr/tests​/⁠inputs</em> directory to show the features that the challenge program will implement.
You should change into this directory if you want to execute the following commands:</p>

<pre data-type="programlisting">$ cd 08_cutr/tests/inputs</pre>

<p>First, consider<a data-primary="fixed-width text files" data-type="indexterm" id="id967"/> a file of <em>fixed-width text</em> where each column occupies a fixed number of characters:</p>

<pre data-type="programlisting">$ cat books.txt
Author              Year Title
Émile Zola          1865 La Confession de Claude
Samuel Beckett      1952 Waiting for Godot
Jules Verne         1870 20,000 Leagues Under the Sea</pre>

<p>The <em>Author</em> column takes the first 20 characters:</p>

<pre data-type="programlisting">$ cut -c 1-20 books.txt
Author
Émile Zola
Samuel Beckett
Jules Verne</pre>

<p>The publication <em>Year</em> column spans the next five characters:</p>

<pre data-type="programlisting">$ cut -c 21-25 books.txt
Year
1865
1952
1870</pre>

<p>The <em>Title</em> column fills the remainder of the line, where the longest title is 28 characters.
Note here that I intentionally request a larger range than exists to show that this is not considered an error:</p>

<pre data-type="programlisting">$ cut -c 26-70 books.txt
Title
La Confession de Claude
Waiting for Godot
20,000 Leagues Under the Sea</pre>

<p>The program does not allow me to rearrange the output by requesting the range <code>26-55</code> for the <em>Title</em> followed by the range <code>1-20</code> for the <em>Author</em>.
Instead, the selections are placed in their original, ascending order:</p>

<pre data-type="programlisting">$ cut -c 26-55,1-20 books.txt
Author              Title
Émile Zola          La Confession de Claude
Samuel Beckett      Waiting for Godot
Jules Verne         20,000 Leagues Under the Sea</pre>

<p>I can use the option <code>-c 1</code> to select the first character, like so:</p>

<pre data-type="programlisting">$ cut -c 1 books.txt
A
É
S
J</pre>

<p>As you’ve seen in previous chapters, bytes and characters are not always interchangeable.<a data-primary="bytes" data-type="indexterm" id="id968"/><a data-primary="characters" data-type="indexterm" id="id969"/><a data-primary="Unicode" data-type="indexterm" id="id970"/>
For instance, the <em>É</em> in <em>Émile Zola</em> is a Unicode character that is composed of two bytes, so asking for just one byte will result in invalid UTF-8 that is represented with the Unicode replacement character:</p>

<pre data-type="programlisting">$ cut -b 1 books.txt
A
�
S
J</pre>

<p>In my experience, fixed-width datafiles are less common than those where the columns of data are delimited by a character such as a comma or a tab.<a data-primary="delimiters" data-secondary="tab and comma" data-type="indexterm" id="id971"/><a data-primary="tab-separated values (.tsv) files" data-type="indexterm" id="id972"/><a data-primary="TSV (tab-separated values) files" data-type="indexterm" id="id973"/>
Consider the same data in the file <em>books.tsv</em>, where the file extension <em>.tsv</em> stands for <em>tab-separated values</em> (TSV), and the columns are delimited by the tab:</p>

<pre data-type="programlisting">$ cat books.tsv
Author	Year	Title
Émile Zola	1865	La Confession de Claude
Samuel Beckett	1952	Waiting for Godot
Jules Verne	1870	20,000 Leagues Under the Sea</pre>

<p>By default, <code>cut</code> will assume the tab character is the field delimiter, so I can use the <code>-f</code> option to select, for instance, the publication year in the second column and the title in the third column, like so:</p>

<pre data-type="programlisting">$ cut -f 2,3 books.tsv
Year	Title
1865	La Confession de Claude
1952	Waiting for Godot
1870	20,000 Leagues Under the Sea</pre>

<p>The comma is another common delimiter, and such<a data-primary="comma-separated values (CSV) files" data-type="indexterm" id="id974"/> files often have the extension <em>.csv</em> for <em>comma-separated values</em> (CSV).<a data-primary="CSV (comma-separated values) files" data-type="indexterm" id="id975"/>
Following is the same data as a CSV file:</p>

<pre data-type="programlisting">$ cat books.csv
Author,Year,Title
Émile Zola,1865,La Confession de Claude
Samuel Beckett,1952,Waiting for Godot
Jules Verne,1870,"20,000 Leagues Under the Sea"</pre>

<p>To parse a CSV file, I must indicate the delimiter with the <code>-d</code> option.
Note that I’m still unable to reorder the fields in the output, as I indicate <code>2,1</code> for the second column followed by the first, but I get the columns back in their original order:</p>

<pre data-type="programlisting">$ cut -d , -f 2,1 books.csv
Author,Year
Émile Zola,1865
Samuel Beckett,1952
Jules Verne,1870</pre>

<p>You may have noticed that the third title contains a comma in <em>20,000</em> and so the title has been enclosed in quotes to indicate that this comma is not a field delimiter.<a data-primary="delimiters" data-secondary="escaping" data-type="indexterm" id="id976"/><a data-primary="escaping special characters" data-secondary="delimiters" data-type="indexterm" id="id977"/><a data-primary="&quot; &quot; (quotation marks, double)" data-secondary="escaping delimiters" data-type="indexterm" id="id978"/>
This is a way to <em>escape</em> the delimiter, or to tell the parser to ignore it.
Unfortunately, neither the BSD nor the GNU version of <code>cut</code> recognizes this and so will truncate the title 
<span class="keep-together">prematurely:</span></p>

<pre data-type="programlisting">$ cut -d , -f 1,3 books.csv
Author,Title
Émile Zola,La Confession de Claude
Samuel Beckett,Waiting for Godot
Jules Verne,"20</pre>

<p>Noninteger values for any of the <code>list</code> option values are rejected:</p>

<pre data-type="programlisting">$ cut -f foo,bar books.tsv
cut: [-cf] list: illegal list value</pre>

<p>Any error opening a file is handled in the course of processing, printing a message to <code>STDERR</code>.
In the following example, <em>blargh</em> represents a nonexistent file:</p>

<pre data-type="programlisting">$ cut -c 1 books.txt <strong>blargh</strong> movies1.csv
A
É
S
J
<strong>cut: blargh: No such file or directory</strong>
t
T
L</pre>

<p>Finally, the program will read <code>STDIN</code> by default or if the given input filename is a 
<span class="keep-together">dash (<code>-</code>):</span></p>

<pre data-type="programlisting">$ cat books.tsv | cut -f 2
Year
1865
1952
1870</pre>

<p>The challenge program is expected to implement just this much, with the following<a data-primary="ranges" data-secondary="changes in cutr utility" data-type="indexterm" id="id979"/> changes:</p>

<ul>
<li>
<p>Ranges must indicate both start and stop values (inclusive).</p>
</li>
<li>
<p>Selection ranges should be printed in the order specified by the user.</p>
</li>
<li>
<p>Ranges may include repeated values.</p>
</li>
<li>
<p>The parsing of delimited text files should respect escaped delimiters.<a data-primary="cut utility" data-secondary="how it works" data-startref="ix_cuthow" data-type="indexterm" id="id980"/></p>
</li>
</ul>
</div></section>






<section data-pdf-bookmark="Getting Started" data-type="sect1"><div class="sect1" id="id77">
<h1>Getting Started</h1>

<p>The name of the challenge program should be <code>cutr</code> (pronounced <em>cut-er</em>) for a Rust version of <code>cut</code>.<a data-primary="cut utility" data-secondary="writing cutr version" data-tertiary="getting started" data-type="indexterm" id="id981"/>
I recommend you begin with <strong><code>cargo new cutr</code></strong> and then copy the <em>08_cutr/tests</em> directory into your project.
My solution will use the following crates, which you should add to your <em>Cargo.toml</em>:</p>

<pre data-code-language="toml" data-type="programlisting"><code class="k">[</code><code class="k">dependencies</code><code class="k">]</code><code class="w">
</code><code class="n">anyhow</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"</code><code class="s2">1.0.79</code><code class="s2">"</code><code class="w">
</code><code class="n">clap</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">version</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s2">"</code><code class="s2">4.5.0</code><code class="s2">"</code><code class="p">,</code><code class="w"> </code><code class="n">features</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"</code><code class="s2">derive</code><code class="s2">"</code><code class="p">]</code><code class="w"> </code><code class="p">}</code><code class="w">
</code><code class="n">csv</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"</code><code class="s2">1.3.0</code><code class="s2">"</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO1-1" id="co_shave_and_a_haircut_CO1-1"><img alt="1" src="assets/1.png"/></a><code class="w">
</code><code class="n">regex</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"</code><code class="s2">1.10.3</code><code class="s2">"</code><code class="w">

</code><code class="k">[</code><code class="k">dev-dependencies</code><code class="k">]</code><code class="w">
</code><code class="n">assert_cmd</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"</code><code class="s2">2.0.13</code><code class="s2">"</code><code class="w">
</code><code class="n">predicates</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"</code><code class="s2">3.0.4</code><code class="s2">"</code><code class="w">
</code><code class="n">pretty_assertions</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"</code><code class="s2">1.4.0</code><code class="s2">"</code><code class="w">
</code><code class="n">rand</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"</code><code class="s2">0.8.5</code><code class="s2">"</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_shave_and_a_haircut_CO1-1" id="callout_shave_and_a_haircut_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>
<dd><p>The <a href="https://oreil.ly/cE8fC"><code>csv</code> crate</a> will be used to parse delimited files such as CSV files. <a data-primary="csv crate" data-type="indexterm" id="id982"/><a data-primary="cut utility" data-secondary="writing cutr version" data-tertiary="defining the arguments" data-type="indexterm" id="ix_cutwrdefarg"/></p></dd>
</dl>

<p>Run <strong><code>cargo test</code></strong> to download the dependencies and run the tests, all of which should fail.</p>








<section data-pdf-bookmark="Defining the Arguments" data-type="sect2"><div class="sect2" id="id78">
<h2>Defining the Arguments</h2>

<p>Following is the expected<a data-primary="usage statement" data-secondary="cutr utility" data-type="indexterm" id="id983"/> usage for the program:</p>

<pre data-type="programlisting">$ cargo run -- --help
Rust version of `cut`

Usage: cutr [OPTIONS] &lt;--fields &lt;FIELDS&gt;|--bytes &lt;BYTES&gt;|--chars &lt;CHARS&gt;&gt; <a class="co" href="#callout_shave_and_a_haircut_CO2-1" id="co_shave_and_a_haircut_CO2-1"><img alt="1" src="assets/1.png"/></a>
       [FILES]...

Arguments:
  [FILES]...  Input file(s) [default: -] <a class="co" href="#callout_shave_and_a_haircut_CO2-2" id="co_shave_and_a_haircut_CO2-2"><img alt="2" src="assets/2.png"/></a>

Options:
  -d, --delimiter &lt;DELIMITER&gt;  Field delimiter [default: "\t"] <a class="co" href="#callout_shave_and_a_haircut_CO2-3" id="co_shave_and_a_haircut_CO2-3"><img alt="3" src="assets/3.png"/></a>
  -f, --fields &lt;FIELDS&gt;        Selected fields
  -b, --bytes &lt;BYTES&gt;          Selected bytes
  -c, --chars &lt;CHARS&gt;          Selected chars
  -h, --help                   Print help
  -V, --version                Print version</pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_shave_and_a_haircut_CO2-1" id="callout_shave_and_a_haircut_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>
<dd><p>Exactly one of <code>--fields</code>, <code>--bytes</code>, or <code>--chars</code> is required.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO2-2" id="callout_shave_and_a_haircut_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>
<dd><p>The input files are optional, and the default is <code>STDIN</code> as denoted by a dash.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO2-3" id="callout_shave_and_a_haircut_CO2-3"><img alt="3" src="assets/3.png"/></a></dt>
<dd><p>The default record delimiter is the tab character.</p></dd>
</dl>

<p>To have <code>clap</code> require one of <code>--fields</code>, <code>--bytes</code>, or <code>--chars</code> when using the derive pattern,<a data-primary="derive pattern" data-secondary="using in cutr program" data-type="indexterm" id="id984"/> I will create an <a href="https://oreil.ly/1h53Z"><code>ArgGroup</code></a> using following structures for the program’s  
<span class="keep-together">arguments</span>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[</code><code class="cp">derive(Debug)</code><code class="cp">]</code><code class="w">
</code><code class="k">struct</code><code> </code><code class="nc">Args</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="n">files</code><code>:</code><code> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="p">,</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO3-1" id="co_shave_and_a_haircut_CO3-1"><img alt="1" src="assets/1.png"/></a><code class="w">
    </code><code class="n">delimiter</code><code>:</code><code> </code><code class="nb">String</code><code class="p">,</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO3-2" id="co_shave_and_a_haircut_CO3-2"><img alt="2" src="assets/2.png"/></a><code class="w">
    </code><code class="n">extract</code><code>:</code><code> </code><code class="nc">ArgsExtract</code><code class="p">,</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO3-3" id="co_shave_and_a_haircut_CO3-3"><img alt="3" src="assets/3.png"/></a><code class="w">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="cp">#[</code><code class="cp">derive(Debug)</code><code class="cp">]</code><code class="w">
</code><code class="k">struct</code><code> </code><code class="nc">ArgsExtract</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO3-4" id="co_shave_and_a_haircut_CO3-4"><img alt="4" src="assets/4.png"/></a><code class="w">
    </code><code class="n">fields</code><code>:</code><code> </code><code class="nb">Option</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="p">,</code><code class="w">
</code><code class="w">    </code><code class="n">bytes</code><code>:</code><code> </code><code class="nb">Option</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="p">,</code><code class="w">
</code><code class="w">    </code><code class="n">chars</code><code>:</code><code> </code><code class="nb">Option</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="p">,</code><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_shave_and_a_haircut_CO3-1" id="callout_shave_and_a_haircut_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>
<dd><p>The <code>files</code> parameter is a vector of strings.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO3-2" id="callout_shave_and_a_haircut_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>
<dd><p>The <code>delimiter</code> is the character separating the columns.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO3-3" id="callout_shave_and_a_haircut_CO3-3"><img alt="3" src="assets/3.png"/></a></dt>
<dd><p>The <code>extract</code> field points to a separate struct.<a data-primary="ArgsExtract struct" data-type="indexterm" id="id985"/></p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO3-4" id="callout_shave_and_a_haircut_CO3-4"><img alt="4" src="assets/4.png"/></a></dt>
<dd><p>The <code>ArgsExtract</code> struct is used by <code>clap</code> to group these arguments.</p></dd>
</dl>

<p>If you prefer the derive pattern, annotate the preceding structs to produce the expected usage statement.
If you prefer to use the builder pattern,<a data-primary="builder pattern" data-secondary="using in cutr program" data-type="indexterm" id="id986"/> you can start your <code>get_args</code> by expanding<a data-primary="get_args function" data-secondary="cutr utility" data-type="indexterm" id="id987"/> on the following skeleton.<a data-primary="ArgGroup struct" data-type="indexterm" id="id988"/>
Note that defining an <code>ArgGroup</code> using the builder pattern does not require any separation of structures, but for the sake of consistency, I will use the preceding structs for both versions of the program:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">get_args</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="nc">Args</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">matches</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Command</code>::<code class="n">new</code><code class="p">(</code><code class="s">"cutr"</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="n">version</code><code class="p">(</code><code class="s">"0.1.0"</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="n">author</code><code class="p">(</code><code class="s">"Ken Youens-Clark &lt;kyclark@gmail.com&gt;"</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="n">about</code><code class="p">(</code><code class="s">"Rust version of `cut`"</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="c1">// What goes here?</code>
<code class="w">        </code><code class="p">.</code><code class="n">get_matches</code><code class="p">();</code><code class="w"/>

<code class="w">    </code><code class="n">Args</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">files</code>: <code class="o">..</code><code class="p">.</code><code class="w"/>
<code class="w">        </code><code class="n">delimiter</code>: <code class="o">..</code><code class="p">.</code><code class="w"/>
<code class="w">        </code><code class="n">extract</code>: <code class="o">..</code><code class="p">.</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The first order of business is pretty-printing the runtime values in <code>main</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">args</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">get_args</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"{:#?}"</code><code class="p">,</code><code class="w"> </code><code class="n">args</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>When run with no arguments, your program should fail as follows:</p>

<pre data-type="programlisting">$ cargo run
error: the following required arguments were not provided:
  &lt;--fields &lt;FIELDS&gt;|--bytes &lt;BYTES&gt;|--chars &lt;CHARS&gt;&gt;

Usage: cutr &lt;--fields &lt;FIELDS&gt;|--bytes &lt;BYTES&gt;|--chars &lt;CHARS&gt;&gt; [FILES]...</pre>

<p>When run with one of the required arguments, it should print a struct as follows:</p>

<pre data-type="programlisting">$ cargo run -- -f 1
Args {
    files: [ <a class="co" href="#callout_shave_and_a_haircut_CO4-1" id="co_shave_and_a_haircut_CO4-1"><img alt="1" src="assets/1.png"/></a>
        "-",
    ],
    delimiter: "\t", <a class="co" href="#callout_shave_and_a_haircut_CO4-2" id="co_shave_and_a_haircut_CO4-2"><img alt="2" src="assets/2.png"/></a>
    extract: ArgsExtract {
        fields: Some( <a class="co" href="#callout_shave_and_a_haircut_CO4-3" id="co_shave_and_a_haircut_CO4-3"><img alt="3" src="assets/3.png"/></a>
            "1",
        ),
        bytes: None,
        chars: None,
    },
}</pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_shave_and_a_haircut_CO4-1" id="callout_shave_and_a_haircut_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>
<dd><p>The default file input is a dash.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO4-2" id="callout_shave_and_a_haircut_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>
<dd><p>The default delimiter is a tab.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO4-3" id="callout_shave_and_a_haircut_CO4-3"><img alt="3" src="assets/3.png"/></a></dt>
<dd><p>The <code>--fields</code> value of <code>1</code> is part of the <code>ArgsExtract</code> struct.</p></dd>
</dl>

<p>Verify that the other arguments are parsed correctly:</p>

<pre data-type="programlisting">$ cargo run -- -b 4 -d , tests/inputs/movies1.csv
Args {
    files: [
        "tests/inputs/movies1.csv", <a class="co" href="#callout_shave_and_a_haircut_CO5-1" id="co_shave_and_a_haircut_CO5-1"><img alt="1" src="assets/1.png"/></a>
    ],
    delimiter: ",", <a class="co" href="#callout_shave_and_a_haircut_CO5-2" id="co_shave_and_a_haircut_CO5-2"><img alt="2" src="assets/2.png"/></a>
    extract: ArgsExtract {
        fields: None,
        bytes: Some( <a class="co" href="#callout_shave_and_a_haircut_CO5-3" id="co_shave_and_a_haircut_CO5-3"><img alt="3" src="assets/3.png"/></a>
            "4",
        ),
        chars: None,
    },
}</pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_shave_and_a_haircut_CO5-1" id="callout_shave_and_a_haircut_CO5-1"><img alt="1" src="assets/1.png"/></a></dt>
<dd><p>The positional argument is parsed into the <code>files</code> field.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO5-2" id="callout_shave_and_a_haircut_CO5-2"><img alt="2" src="assets/2.png"/></a></dt>
<dd><p>The <code>-d</code> argument is parsed into the <code>delimiter</code> field.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO5-3" id="callout_shave_and_a_haircut_CO5-3"><img alt="3" src="assets/3.png"/></a></dt>
<dd><p>The <code>-b</code> argument is parsed into the <code>bytes</code> field.</p></dd>
</dl>

<p>The options for <code>-f|--fields</code>, <code>-b|--bytes</code>, and <code>-c|--chars</code> should all be mutually exclusive:</p>

<pre data-type="programlisting">$ cargo run -- -f 1 -b 8-9 tests/inputs/movies1.tsv
error: the argument '--fields &lt;FIELDS&gt;' cannot be used with '--bytes &lt;BYTES&gt;'

Usage: cutr &lt;--fields &lt;FIELDS&gt;|--bytes &lt;BYTES&gt;|--chars &lt;CHARS&gt;&gt; [FILES]...</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Stop reading and get your program to match the preceding behavior. It should pass five tests for bad inputs when you run <strong><code>cargo test dies</code></strong>.</p>
</div>

<p>If you chose the builder pattern, your <code>get_args</code> function probably looks like the following.<a data-primary="get_args function" data-secondary="cutr utility" data-type="indexterm" id="id989"/>
Be sure to add <code>use clap::{Arg, ArgGroup, Command}</code> for the following code:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code><code> </code><code class="nf">get_args</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code>-&gt;</code><code> </code><code class="nc">Args</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">matches</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Command</code><code>::</code><code class="n">new</code><code class="p">(</code><code class="s">"</code><code class="s">cutr</code><code class="s">"</code><code class="p">)</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">version</code><code class="p">(</code><code class="s">"</code><code class="s">0.1.0</code><code class="s">"</code><code class="p">)</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">author</code><code class="p">(</code><code class="s">"</code><code class="s">Ken Youens-Clark &lt;kyclark@gmail.com&gt;</code><code class="s">"</code><code class="p">)</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">about</code><code class="p">(</code><code class="s">"</code><code class="s">Rust version of `cut`</code><code class="s">"</code><code class="p">)</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">arg</code><code class="p">(</code><code class="w">
</code><code class="w">            </code><code class="n">Arg</code><code>::</code><code class="n">new</code><code class="p">(</code><code class="s">"</code><code class="s">files</code><code class="s">"</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO6-1" id="co_shave_and_a_haircut_CO6-1"><img alt="1" src="assets/1.png"/></a><code class="w">
                </code><code class="p">.</code><code class="n">value_name</code><code class="p">(</code><code class="s">"</code><code class="s">FILES</code><code class="s">"</code><code class="p">)</code><code class="w">
</code><code class="w">                </code><code class="p">.</code><code class="n">help</code><code class="p">(</code><code class="s">"</code><code class="s">Input file(s)</code><code class="s">"</code><code class="p">)</code><code class="w">
</code><code class="w">                </code><code class="p">.</code><code class="n">num_args</code><code class="p">(</code><code class="mi">0</code><code class="o">..</code><code class="p">)</code><code class="w">
</code><code class="w">                </code><code class="p">.</code><code class="n">default_value</code><code class="p">(</code><code class="s">"</code><code class="s">-</code><code class="s">"</code><code class="p">)</code><code class="p">,</code><code class="w">
</code><code class="w">        </code><code class="p">)</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">arg</code><code class="p">(</code><code class="w">
</code><code class="w">            </code><code class="n">Arg</code><code>::</code><code class="n">new</code><code class="p">(</code><code class="s">"</code><code class="s">delimiter</code><code class="s">"</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO6-2" id="co_shave_and_a_haircut_CO6-2"><img alt="2" src="assets/2.png"/></a><code class="w">
                </code><code class="p">.</code><code class="n">value_name</code><code class="p">(</code><code class="s">"</code><code class="s">DELIMITER</code><code class="s">"</code><code class="p">)</code><code class="w">
</code><code class="w">                </code><code class="p">.</code><code class="n">short</code><code class="p">(</code><code class="sc">'d'</code><code class="p">)</code><code class="w">
</code><code class="w">                </code><code class="p">.</code><code class="n">long</code><code class="p">(</code><code class="s">"</code><code class="s">delim</code><code class="s">"</code><code class="p">)</code><code class="w">
</code><code class="w">                </code><code class="p">.</code><code class="n">help</code><code class="p">(</code><code class="s">"</code><code class="s">Field delimiter</code><code class="s">"</code><code class="p">)</code><code class="w">
</code><code class="w">                </code><code class="p">.</code><code class="n">default_value</code><code class="p">(</code><code class="s">"</code><code class="se">\t</code><code class="s">"</code><code class="p">)</code><code class="p">,</code><code class="w">
</code><code class="w">        </code><code class="p">)</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">arg</code><code class="p">(</code><code class="w">
</code><code class="w">            </code><code class="n">Arg</code><code>::</code><code class="n">new</code><code class="p">(</code><code class="s">"</code><code class="s">fields</code><code class="s">"</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO6-3" id="co_shave_and_a_haircut_CO6-3"><img alt="3" src="assets/3.png"/></a><code class="w">
                </code><code class="p">.</code><code class="n">value_name</code><code class="p">(</code><code class="s">"</code><code class="s">FIELDS</code><code class="s">"</code><code class="p">)</code><code class="w">
</code><code class="w">                </code><code class="p">.</code><code class="n">short</code><code class="p">(</code><code class="sc">'f'</code><code class="p">)</code><code class="w">
</code><code class="w">                </code><code class="p">.</code><code class="n">long</code><code class="p">(</code><code class="s">"</code><code class="s">fields</code><code class="s">"</code><code class="p">)</code><code class="w">
</code><code class="w">                </code><code class="p">.</code><code class="n">help</code><code class="p">(</code><code class="s">"</code><code class="s">Selected fields</code><code class="s">"</code><code class="p">)</code><code class="p">,</code><code class="w">
</code><code class="w">        </code><code class="p">)</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">arg</code><code class="p">(</code><code class="w">
</code><code class="w">            </code><code class="n">Arg</code><code>::</code><code class="n">new</code><code class="p">(</code><code class="s">"</code><code class="s">bytes</code><code class="s">"</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO6-4" id="co_shave_and_a_haircut_CO6-4"><img alt="4" src="assets/4.png"/></a><code class="w">
                </code><code class="p">.</code><code class="n">value_name</code><code class="p">(</code><code class="s">"</code><code class="s">BYTES</code><code class="s">"</code><code class="p">)</code><code class="w">
</code><code class="w">                </code><code class="p">.</code><code class="n">short</code><code class="p">(</code><code class="sc">'b'</code><code class="p">)</code><code class="w">
</code><code class="w">                </code><code class="p">.</code><code class="n">long</code><code class="p">(</code><code class="s">"</code><code class="s">bytes</code><code class="s">"</code><code class="p">)</code><code class="w">
</code><code class="w">                </code><code class="p">.</code><code class="n">help</code><code class="p">(</code><code class="s">"</code><code class="s">Selected bytes</code><code class="s">"</code><code class="p">)</code><code class="p">,</code><code class="w">
</code><code class="w">        </code><code class="p">)</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">arg</code><code class="p">(</code><code class="w">
</code><code class="w">            </code><code class="n">Arg</code><code>::</code><code class="n">new</code><code class="p">(</code><code class="s">"</code><code class="s">chars</code><code class="s">"</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO6-5" id="co_shave_and_a_haircut_CO6-5"><img alt="5" src="assets/5.png"/></a><code class="w">
                </code><code class="p">.</code><code class="n">value_name</code><code class="p">(</code><code class="s">"</code><code class="s">CHARS</code><code class="s">"</code><code class="p">)</code><code class="w">
</code><code class="w">                </code><code class="p">.</code><code class="n">short</code><code class="p">(</code><code class="sc">'c'</code><code class="p">)</code><code class="w">
</code><code class="w">                </code><code class="p">.</code><code class="n">long</code><code class="p">(</code><code class="s">"</code><code class="s">chars</code><code class="s">"</code><code class="p">)</code><code class="w">
</code><code class="w">                </code><code class="p">.</code><code class="n">help</code><code class="p">(</code><code class="s">"</code><code class="s">Selected characters</code><code class="s">"</code><code class="p">)</code><code class="p">,</code><code class="w">
</code><code class="w">        </code><code class="p">)</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">group</code><code class="p">(</code><code class="w">
</code><code class="w">            </code><code class="n">ArgGroup</code><code>::</code><code class="n">new</code><code class="p">(</code><code class="s">"</code><code class="s">extract</code><code class="s">"</code><code class="p">)</code><code class="w">
</code><code class="w">                </code><code class="p">.</code><code class="n">args</code><code class="p">(</code><code class="p">[</code><code class="s">"</code><code class="s">fields</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">bytes</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">chars</code><code class="s">"</code><code class="p">]</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO6-6" id="co_shave_and_a_haircut_CO6-6"><img alt="6" src="assets/6.png"/></a><code class="w">
                </code><code class="p">.</code><code class="n">required</code><code class="p">(</code><code class="kc">true</code><code class="p">)</code><code class="w">
</code><code class="w">                </code><code class="p">.</code><code class="n">multiple</code><code class="p">(</code><code class="kc">false</code><code class="p">)</code><code class="p">,</code><code class="w">
</code><code class="w">        </code><code class="p">)</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">get_matches</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">    </code><code class="n">Args</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">        </code><code class="n">files</code><code>:</code><code> </code><code class="nc">matches</code><code class="p">.</code><code class="n">get_many</code><code class="p">(</code><code class="s">"</code><code class="s">files</code><code class="s">"</code><code class="p">)</code><code class="p">.</code><code class="n">unwrap</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="n">cloned</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="n">collect</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code class="w">
</code><code class="w">        </code><code class="n">delimiter</code><code>:</code><code> </code><code class="nc">matches</code><code class="p">.</code><code class="n">get_one</code><code class="p">(</code><code class="s">"</code><code class="s">delimiter</code><code class="s">"</code><code class="p">)</code><code class="p">.</code><code class="n">cloned</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="n">unwrap</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code class="w">
</code><code class="w">        </code><code class="n">extract</code><code>:</code><code> </code><code class="nc">ArgsExtract</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO6-7" id="co_shave_and_a_haircut_CO6-7"><img alt="7" src="assets/7.png"/></a><code class="w">
            </code><code class="n">fields</code><code>:</code><code> </code><code class="nc">matches</code><code class="p">.</code><code class="n">get_one</code><code class="p">(</code><code class="s">"</code><code class="s">fields</code><code class="s">"</code><code class="p">)</code><code class="p">.</code><code class="n">cloned</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code class="w">
</code><code class="w">            </code><code class="n">bytes</code><code>:</code><code> </code><code class="nc">matches</code><code class="p">.</code><code class="n">get_one</code><code class="p">(</code><code class="s">"</code><code class="s">bytes</code><code class="s">"</code><code class="p">)</code><code class="p">.</code><code class="n">cloned</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code class="w">
</code><code class="w">            </code><code class="n">chars</code><code>:</code><code> </code><code class="nc">matches</code><code class="p">.</code><code class="n">get_one</code><code class="p">(</code><code class="s">"</code><code class="s">chars</code><code class="s">"</code><code class="p">)</code><code class="p">.</code><code class="n">cloned</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code class="w">
</code><code class="w">        </code><code class="p">}</code><code class="p">,</code><code class="w">
</code><code class="w">    </code><code class="p">}</code><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_shave_and_a_haircut_CO6-1" id="callout_shave_and_a_haircut_CO6-1"><img alt="1" src="assets/1.png"/></a></dt>
<dd><p>The <code>files</code> argument is positional, not required, and defaults to a dash.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO6-2" id="callout_shave_and_a_haircut_CO6-2"><img alt="2" src="assets/2.png"/></a></dt>
<dd><p>The <code>delimiter</code> option defaults to a tab.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO6-3" id="callout_shave_and_a_haircut_CO6-3"><img alt="3" src="assets/3.png"/></a></dt>
<dd><p><code>fields</code> is optional.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO6-4" id="callout_shave_and_a_haircut_CO6-4"><img alt="4" src="assets/4.png"/></a></dt>
<dd><p><code>bytes</code> is optional.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO6-5" id="callout_shave_and_a_haircut_CO6-5"><img alt="5" src="assets/5.png"/></a></dt>
<dd><p><code>chars</code> is optional.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO6-6" id="callout_shave_and_a_haircut_CO6-6"><img alt="6" src="assets/6.png"/></a></dt>
<dd><p>This creates an argument group that requires exactly one of the members.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO6-7" id="callout_shave_and_a_haircut_CO6-7"><img alt="7" src="assets/7.png"/></a></dt>
<dd><p>A struct can contain another struct.</p></dd>
</dl>

<p>The derive pattern requires <code>use clap::Parser</code> and looks <a data-primary="derive pattern" data-secondary="using in cutr program" data-type="indexterm" id="id990"/><a data-primary="clap::Parser trait" data-type="indexterm" id="id991"/><a data-primary="Parser trait" data-type="indexterm" id="id992"/>like the following:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[</code><code class="cp">derive(Debug, Parser)</code><code class="cp">]</code><code class="w">
</code><code class="cp">#[</code><code class="cp">command(author, version, about)</code><code class="cp">]</code><code class="w">
</code><code class="sd">/// Rust version of `cut`
</code><code class="k">struct</code><code> </code><code class="nc">Args</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="sd">/// Input file(s)
</code><code class="w">    </code><code class="cp">#[</code><code class="cp">arg(default_value = </code><code class="s">"</code><code class="s">-</code><code class="s">"</code><code class="cp">)</code><code class="cp">]</code><code class="w">
</code><code class="w">    </code><code class="n">files</code><code>:</code><code> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="p">,</code><code class="w">
</code><code class="w">
</code><code class="w">    </code><code class="sd">/// Field delimiter
</code><code class="w">    </code><code class="cp">#[</code><code class="cp">arg(short, long, value_name = </code><code class="s">"</code><code class="s">DELIMITER</code><code class="s">"</code><code class="cp">, default_value = </code><code class="s">"</code><code class="se">\t</code><code class="s">"</code><code class="cp">)</code><code class="cp">]</code><code class="w">
</code><code class="w">    </code><code class="n">delimiter</code><code>:</code><code> </code><code class="nb">String</code><code class="p">,</code><code class="w">
</code><code class="w">
</code><code class="w">    </code><code class="cp">#[</code><code class="cp">command(flatten)</code><code class="cp">]</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO7-1" id="co_shave_and_a_haircut_CO7-1"><img alt="1" src="assets/1.png"/></a><code class="w">
    </code><code class="n">extract</code><code>:</code><code> </code><code class="nc">ArgsExtract</code><code class="p">,</code><code class="w">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="cp">#[</code><code class="cp">derive(Debug, clap::Args)</code><code class="cp">]</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO7-2" id="co_shave_and_a_haircut_CO7-2"><img alt="2" src="assets/2.png"/></a><code class="w">
</code><code class="cp">#[</code><code class="cp">group(required = true, multiple = false)</code><code class="cp">]</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO7-3" id="co_shave_and_a_haircut_CO7-3"><img alt="3" src="assets/3.png"/></a><code class="w">
</code><code class="k">struct</code><code> </code><code class="nc">ArgsExtract</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="sd">/// Selected fields
</code><code class="w">    </code><code class="cp">#[</code><code class="cp">arg(short, long, value_name = </code><code class="s">"</code><code class="s">FIELDS</code><code class="s">"</code><code class="cp">)</code><code class="cp">]</code><code class="w">
</code><code class="w">    </code><code class="n">fields</code><code>:</code><code> </code><code class="nb">Option</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="p">,</code><code class="w">
</code><code class="w">
</code><code class="w">    </code><code class="sd">/// Selected bytes
</code><code class="w">    </code><code class="cp">#[</code><code class="cp">arg(short, long, value_name = </code><code class="s">"</code><code class="s">BYTES</code><code class="s">"</code><code class="cp">)</code><code class="cp">]</code><code class="w">
</code><code class="w">    </code><code class="n">bytes</code><code>:</code><code> </code><code class="nb">Option</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="p">,</code><code class="w">
</code><code class="w">
</code><code class="w">    </code><code class="sd">/// Selected chars
</code><code class="w">    </code><code class="cp">#[</code><code class="cp">arg(short, long, value_name = </code><code class="s">"</code><code class="s">CHARS</code><code class="s">"</code><code class="cp">)</code><code class="cp">]</code><code class="w">
</code><code class="w">    </code><code class="n">chars</code><code>:</code><code> </code><code class="nb">Option</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="p">,</code><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_shave_and_a_haircut_CO7-1" id="callout_shave_and_a_haircut_CO7-1"><img alt="1" src="assets/1.png"/></a></dt>
<dd><p>The <code>flatten</code> will merge the <code>ArgsExtract</code> into the <code>Args</code> struct.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO7-2" id="callout_shave_and_a_haircut_CO7-2"><img alt="2" src="assets/2.png"/></a></dt>
<dd><p>Note that I <code>derive</code> from the fully qualified <code>clap::Args</code> to avoid namespace collisions with my own <code>Args</code>.<a data-primary="flatten command" data-type="indexterm" id="id993"/></p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO7-3" id="callout_shave_and_a_haircut_CO7-3"><img alt="3" src="assets/3.png"/></a></dt>
<dd><p>The <code>group</code> annotation creates the <code>ArgGroup</code>.<a data-primary="group annotation" data-type="indexterm" id="id994"/></p></dd>
</dl>

<p>Next, it’s time to go further in validating the arguments.<a data-primary="cut utility" data-secondary="writing cutr version" data-startref="ix_cutwrdefarg" data-tertiary="defining the arguments" data-type="indexterm" id="id995"/></p>
</div></section>








<section data-pdf-bookmark="Validating the Delimiter" data-type="sect2"><div class="sect2" id="id79">
<h2>Validating the Delimiter</h2>

<p>I first suggest you introduce a <code>run</code> function as<a data-primary="delimiters" data-secondary="validating delimiter in cutr" data-type="indexterm" id="ix_delval"/><a data-primary="cut utility" data-secondary="writing cutr version" data-tertiary="validating the delimiter" data-type="indexterm" id="ix_cutwrvaldel"/> in previous chapters.
Add 
<span class="keep-together"><code>use anyhow::Result</code></span> and the following:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Err</code><code class="p">(</code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">run</code><code class="p">(</code><code class="n">Args</code>::<code class="n">parse</code><code class="p">())</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="fm">eprintln!</code><code class="p">(</code><code class="s">"{e}"</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="n">std</code>::<code class="n">process</code>::<code class="n">exit</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="k">fn</code> <code class="nf">run</code><code class="p">(</code><code class="n">_args</code>: <code class="nc">Args</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="p">()</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">Ok</code><code class="p">(())</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Later in the program, I’ll be using the <a href="https://oreil.ly/B3F6c"><code>csv</code> crate</a> to parse the input file, which requires the delimiter to be a single unsigned 8-bit integer <a href="https://oreil.ly/P5d3b"><code>u8</code></a>.
The program currently fails the test <strong><code>cargo test dies_bad_delimiter</code></strong> that ensures the delimiter input is correct.
I can look at the source code in <em>tests/cli.rs</em> to see the expected error 
<span class="keep-together">message</span>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[</code><code class="cp">test</code><code class="cp">]</code><code class="w">
</code><code class="k">fn</code><code> </code><code class="nf">dies_bad_delimiter</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code>-&gt;</code><code> </code><code class="nb">Result</code><code class="o">&lt;</code><code class="p">(</code><code class="p">)</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="n">dies</code><code class="p">(</code><code class="w">
</code><code class="w">        </code><code class="o">&amp;</code><code class="p">[</code><code class="n">CSV</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">-f</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">1</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">-d</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">,,</code><code class="s">"</code><code class="p">]</code><code class="p">,</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO8-1" id="co_shave_and_a_haircut_CO8-1"><img alt="1" src="assets/1.png"/></a><code class="w">
        </code><code class="s">r#"--delim ",," must be a single byte"#</code><code class="p">,</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO8-2" id="co_shave_and_a_haircut_CO8-2"><img alt="2" src="assets/2.png"/></a><code class="w">
    </code><code class="p">)</code><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_shave_and_a_haircut_CO8-1" id="callout_shave_and_a_haircut_CO8-1"><img alt="1" src="assets/1.png"/></a></dt>
<dd><p>The program is run with two commas for the delimiter.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO8-2" id="callout_shave_and_a_haircut_CO8-2"><img alt="2" src="assets/2.png"/></a></dt>
<dd><p>The error should echo the given delimiter along with how to fix the input.</p></dd>
</dl>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Stop reading and write the code necessary to pass this test. Be aware that I added <code>use anyhow::bail</code> to include the <a href="https://oreil.ly/wCanm"><code>bail</code></a> macro to return from <code>run</code> with an error message.<a data-primary="anyhow::bail macro" data-type="indexterm" id="id996"/><a data-primary="bail! macro" data-type="indexterm" id="id997"/></p>
</div>

<p>Following<a data-primary="bytes" data-secondary="ensuring the delimiter is single byte" data-type="indexterm" id="id998"/> is how I ensure that the delimiter is a single byte:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code><code> </code><code class="nf">run</code><code class="p">(</code><code class="n">args</code><code>:</code><code> </code><code class="nc">Args</code><code class="p">)</code><code class="w"> </code><code>-&gt;</code><code> </code><code class="nb">Result</code><code class="o">&lt;</code><code class="p">(</code><code class="p">)</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">delim_bytes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">args</code><code class="p">.</code><code class="n">delimiter</code><code class="p">.</code><code class="n">as_bytes</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO9-1" id="co_shave_and_a_haircut_CO9-1"><img alt="1" src="assets/1.png"/></a><code class="w">
    </code><code class="k">if</code><code class="w"> </code><code class="n">delim_bytes</code><code class="p">.</code><code class="n">len</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">!</code><code class="o">=</code><code class="w"> </code><code class="mi">1</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO9-2" id="co_shave_and_a_haircut_CO9-2"><img alt="2" src="assets/2.png"/></a><code class="w">
        </code><code class="n">bail</code><code class="o">!</code><code class="p">(</code><code class="s">r#"--delim "{}" must be a single byte"#</code><code class="p">,</code><code class="w"> </code><code class="n">args</code><code class="p">.</code><code class="n">delimiter</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO9-3" id="co_shave_and_a_haircut_CO9-3"><img alt="3" src="assets/3.png"/></a><code class="w">
    </code><code class="p">}</code><code class="w">
</code><code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">delimiter</code><code>:</code><code> </code><code class="kt">u8</code><code> </code><code class="o">=</code><code class="w"> </code><code class="o">*</code><code class="n">delim_bytes</code><code class="p">.</code><code class="n">first</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="n">unwrap</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO9-4" id="co_shave_and_a_haircut_CO9-4"><img alt="4" src="assets/4.png"/></a><code class="w">
    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"</code><code class="s">{delimiter}</code><code class="s">"</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">    </code><code class="nb">Ok</code><code class="p">(</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_shave_and_a_haircut_CO9-1" id="callout_shave_and_a_haircut_CO9-1"><img alt="1" src="assets/1.png"/></a></dt>
<dd><p>Use <a href="https://oreil.ly/e-MWZ"><code>String::as_bytes</code></a> to break the string into a vector of <code>u8</code>.<a data-primary="String::as_bytes method" data-type="indexterm" id="id999"/><a data-primary="vectors" data-secondary="breaking string into vector of u8" data-type="indexterm" id="id1000"/></p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO9-2" id="callout_shave_and_a_haircut_CO9-2"><img alt="2" src="assets/2.png"/></a></dt>
<dd><p>Check if the vector’s length is any value other than one.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO9-3" id="callout_shave_and_a_haircut_CO9-3"><img alt="3" src="assets/3.png"/></a></dt>
<dd><p>Return an error using a <em>raw</em> string<a data-primary="raw strings" data-type="indexterm" id="id1001"/><a data-primary="strings" data-secondary="raw, in regular expressions" data-type="indexterm" id="id1002"/><a data-primary="&quot; &quot; (quotation marks, double)" data-secondary="enclosing raw string in regular expression" data-type="indexterm" id="id1003"/> so the contained double quotes do not require escaping.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO9-4" id="callout_shave_and_a_haircut_CO9-4"><img alt="4" src="assets/4.png"/></a></dt>
<dd><p>Use <a href="https://oreil.ly/rFrS8"><code>Vec::first</code></a> to select the first element of the vector.<a data-primary="Vec::first function" data-type="indexterm" id="id1004"/><a data-primary="Option::unwrap function" data-type="indexterm" id="id1005"/> Because I have verified that this vector has exactly one byte, it is safe to call <code>Option::unwrap</code>.</p></dd>
</dl>

<p>In the preceding code, I use the <a href="https://oreil.ly/VCe9J"><code>Deref::deref</code></a> operator <code>*</code> in the expression <code>*delim_bytes</code> to dereference the variable, which is a <code>&amp;u8</code>.<a data-primary="Deref::deref operator" data-type="indexterm" id="id1006"/><a data-primary="* (asterisk)" data-secondary="dereference operator" data-type="indexterm" id="id1007"/>
The code will not compile without the asterisk, and the error message shows exactly where to add the dereference operator:</p>

<pre data-type="programlisting">error[E0308]: mismatched types
  --&gt; src/main.rs:59:25
   |
59 |     let delimiter: u8 = delim_bytes.first().unwrap();
   |                    --   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u8`,
   |                    |                                 found `&amp;u8`
   |                    |
   |                    expected due to this
   |
help: consider dereferencing the borrow
   |
59 |     let delimiter: u8 = *delim_bytes.first().unwrap();
   |                         +</pre>
</div></section>








<section data-pdf-bookmark="Requirements for Parsing the Position List" data-type="sect2"><div class="sect2" id="id80">
<h2>Requirements for Parsing the Position List</h2>

<p>I will define a <a data-primary="cut utility" data-secondary="writing cutr version" data-startref="ix_cutwrvaldel" data-tertiary="validating the delimiter" data-type="indexterm" id="id1008"/><a data-primary="cut utility" data-secondary="writing cutr version" data-tertiary="requirements for parsing position list" data-type="indexterm" id="ix_cutwrreqprs"/><a data-primary="PositionList type alias" data-type="indexterm" id="id1009"/>type alias <code>PositionList</code> to describe the fields, bytes, or characters that I want to display from the input files.
This is a <code>Vec&lt;Range&lt;usize&gt;&gt;</code> or a vector of <a href="https://oreil.ly/gA0sx"><code>std::ops::Range</code> structs</a> to represent spans of positive integer values.<a data-primary="std::ops::Range structs" data-type="indexterm" id="id1010"/><a data-primary="Range structs" data-type="indexterm" id="id1011"/><a data-primary="Vec&lt;Range&lt;usize&gt;&gt;" data-type="indexterm" id="id1012"/>
I will then use this type in a new <code>enum</code> to say which of <code>Fields</code>, <code>Bytes</code>, or <code>Chars</code> I should extract:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">type</code><code> </code><code class="nc">PositionList</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">Range</code><code class="o">&lt;</code><code class="kt">usize</code><code class="o">&gt;</code><code class="o">&gt;</code><code class="p">;</code><a class="co" href="#callout_shave_and_a_haircut_CO10-1" id="co_shave_and_a_haircut_CO10-1"><img alt="1" src="assets/1.png"/></a><code class="w">
</code><code class="w">
</code><code class="cp">#[</code><code class="cp">derive(Debug)</code><code class="cp">]</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO10-2" id="co_shave_and_a_haircut_CO10-2"><img alt="2" src="assets/2.png"/></a><code class="w">
</code><code class="k">pub</code><code class="w"> </code><code class="k">enum</code><code> </code><code class="nc">Extract</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="n">Fields</code><code class="p">(</code><code class="n">PositionList</code><code class="p">)</code><code class="p">,</code><code class="w">
</code><code class="w">    </code><code class="n">Bytes</code><code class="p">(</code><code class="n">PositionList</code><code class="p">)</code><code class="p">,</code><code class="w">
</code><code class="w">    </code><code class="n">Chars</code><code class="p">(</code><code class="n">PositionList</code><code class="p">)</code><code class="p">,</code><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_shave_and_a_haircut_CO10-1" id="callout_shave_and_a_haircut_CO10-1"><img alt="1" src="assets/1.png"/></a></dt>
<dd><p>A <code>PositionList</code> is a vector of <code>Range&lt;usize&gt;</code> values.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO10-2" id="callout_shave_and_a_haircut_CO10-2"><img alt="2" src="assets/2.png"/></a></dt>
<dd><p>Define an <code>enum</code> to hold the variants for extracting fields, bytes, or characters.<a data-primary="fields, bytes, or characters, extracting" data-type="indexterm" id="id1013"/><a data-primary="extracting bytes, characters, or fields" data-type="indexterm" id="id1014"/></p></dd>
</dl>

<p>Unlike the original <code>cut</code> tool, the challenge program will allow only for the input ranges to be a comma-separated list of either single numbers or closed ranges like <code>2-4</code>.
Also, the challenge program will use the selections in the given order rather than rearranging them in ascending order.<a data-primary="CSV (comma-separated values) files" data-type="indexterm" id="id1015"/><a data-primary="ranges" data-secondary="position list in cutr utility" data-type="indexterm" id="id1016"/></p>

<p>To parse and validate the range values for the byte, character, and field arguments, I wrote a function called <code>parse_pos</code>.<a data-primary="parse_pos function" data-type="indexterm" id="id1017"/><a data-primary="ranges" data-secondary="parsing and validating for byte, character, and field arguments in cutr" data-type="indexterm" id="id1018"/>
Here is how you might start it:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code><code> </code><code class="nf">parse_pos</code><code class="p">(</code><code class="n">range</code><code>:</code><code> </code><code class="nb">String</code><code class="p">)</code><code class="w"> </code><code>-&gt;</code><code> </code><code class="nb">Result</code><code class="o">&lt;</code><code class="n">PositionList</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO11-1" id="co_shave_and_a_haircut_CO11-1"><img alt="1" src="assets/1.png"/></a><code class="w">
    </code><code class="fm">unimplemented!</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO11-2" id="co_shave_and_a_haircut_CO11-2"><img alt="2" src="assets/2.png"/></a><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_shave_and_a_haircut_CO11-1" id="callout_shave_and_a_haircut_CO11-1"><img alt="1" src="assets/1.png"/></a></dt>
<dd><p>This function accepts a <code>String</code> and will either return a <code>PositionList</code> or an error.<a data-primary="unimplemented! macro" data-type="indexterm" id="id1019"/></p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO11-2" id="callout_shave_and_a_haircut_CO11-2"><img alt="2" src="assets/2.png"/></a></dt>
<dd><p>The <a href="https://oreil.ly/hqKK8"><code>unimplemented!</code> macro</a> will cause the program to <em>panic</em> or prematurely terminate with the message <em>not implemented</em>.</p></dd>
</dl>

<p>To help you along, I have written an extensive unit test for the numbers and number ranges that should be accepted or rejected.
The numbers may have leading zeros but may not have any nonnumeric characters, and number ranges must be denoted with a dash (<code>-</code>).
Multiple numbers and ranges can be separated with commas.
In this chapter, I will create a <code>unit_tests</code> module so that <strong><code>cargo test unit</code></strong> will run all the unit tests.<a data-primary="unit tests" data-secondary="creating for cutr utility" data-type="indexterm" id="id1020"/>
Note that my implementation of <code>parse_pos</code> uses index positions where I 
<span class="keep-together">subtract</span> one from each value for zero-based indexing, but you may prefer to handle this differently.<a data-primary="indexes" data-secondary="in parse_pos function, zero-based index" data-secondary-sortas="parse_pos" data-type="indexterm" id="id1021"/><a data-primary="index positions, use by parse_pos function" data-type="indexterm" id="id1022"/><a data-primary="parse_pos function" data-secondary="index positions" data-type="indexterm" id="id1023"/>
Add the following to your source code:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[cfg(test)]</code><code class="w"/>
<code class="k">mod</code> <code class="nn">unit_tests</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">use</code><code class="w"> </code><code class="k">super</code>::<code class="n">parse_pos</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="cp">#[test]</code><code class="w"/>
<code class="w">    </code><code class="k">fn</code> <code class="nf">test_parse_pos</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// The empty string is an error</code>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">parse_pos</code><code class="p">(</code><code class="s">""</code><code class="p">.</code><code class="n">to_string</code><code class="p">()).</code><code class="n">is_err</code><code class="p">());</code><code class="w"/>

<code class="w">        </code><code class="c1">// Zero is an error</code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"0"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_err</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="w"/>
<code class="w">            </code><code class="n">res</code><code class="p">.</code><code class="n">unwrap_err</code><code class="p">().</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">            </code><code class="s">r#"illegal list value: "0""#</code><code class="w"/>
<code class="w">        </code><code class="p">);</code><code class="w"/>

<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"0-1"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_err</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="w"/>
<code class="w">            </code><code class="n">res</code><code class="p">.</code><code class="n">unwrap_err</code><code class="p">().</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">            </code><code class="s">r#"illegal list value: "0""#</code><code class="w"/>
<code class="w">        </code><code class="p">);</code><code class="w"/>

<code class="w">        </code><code class="c1">// A leading "+" is an error</code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"+1"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_err</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="w"/>
<code class="w">            </code><code class="n">res</code><code class="p">.</code><code class="n">unwrap_err</code><code class="p">().</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">            </code><code class="s">r#"illegal list value: "+1""#</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="p">);</code><code class="w"/>

<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"+1-2"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_err</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="w"/>
<code class="w">            </code><code class="n">res</code><code class="p">.</code><code class="n">unwrap_err</code><code class="p">().</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">            </code><code class="s">r#"illegal list value: "+1-2""#</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="p">);</code><code class="w"/>

<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"1-+2"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_err</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="w"/>
<code class="w">            </code><code class="n">res</code><code class="p">.</code><code class="n">unwrap_err</code><code class="p">().</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">            </code><code class="s">r#"illegal list value: "1-+2""#</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="p">);</code><code class="w"/>

<code class="w">        </code><code class="c1">// Any non-number is an error</code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"a"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_err</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="w"/>
<code class="w">            </code><code class="n">res</code><code class="p">.</code><code class="n">unwrap_err</code><code class="p">().</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">            </code><code class="s">r#"illegal list value: "a""#</code><code class="w"/>
<code class="w">        </code><code class="p">);</code><code class="w"/>

<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"1,a"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_err</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="w"/>
<code class="w">            </code><code class="n">res</code><code class="p">.</code><code class="n">unwrap_err</code><code class="p">().</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">            </code><code class="s">r#"illegal list value: "a""#</code><code class="w"/>
<code class="w">        </code><code class="p">);</code><code class="w"/>

<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"1-a"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_err</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="w"/>
<code class="w">            </code><code class="n">res</code><code class="p">.</code><code class="n">unwrap_err</code><code class="p">().</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">            </code><code class="s">r#"illegal list value: "1-a""#</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="p">);</code><code class="w"/>

<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"a-1"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_err</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="w"/>
<code class="w">            </code><code class="n">res</code><code class="p">.</code><code class="n">unwrap_err</code><code class="p">().</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">            </code><code class="s">r#"illegal list value: "a-1""#</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="p">);</code><code class="w"/>

<code class="w">        </code><code class="c1">// Wonky ranges</code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"-"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_err</code><code class="p">());</code><code class="w"/>

<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">","</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_err</code><code class="p">());</code><code class="w"/>

<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"1,"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_err</code><code class="p">());</code><code class="w"/>

<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"1-"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_err</code><code class="p">());</code><code class="w"/>

<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"1-1-1"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_err</code><code class="p">());</code><code class="w"/>

<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"1-1-a"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_err</code><code class="p">());</code><code class="w"/>

<code class="w">        </code><code class="c1">// First number must be less than second</code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"1-1"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_err</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="w"/>
<code class="w">            </code><code class="n">res</code><code class="p">.</code><code class="n">unwrap_err</code><code class="p">().</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">            </code><code class="s">"First number in range (1) must be lower than second number (1)"</code><code class="w"/>
<code class="w">        </code><code class="p">);</code><code class="w"/>

<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"2-1"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_err</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="w"/>
<code class="w">            </code><code class="n">res</code><code class="p">.</code><code class="n">unwrap_err</code><code class="p">().</code><code class="n">to_string</code><code class="p">(),</code><code class="w"/>
<code class="w">            </code><code class="s">"First number in range (2) must be lower than second number (1)"</code><code class="w"/>
<code class="w">        </code><code class="p">);</code><code class="w"/>

<code class="w">        </code><code class="c1">// All the following are acceptable</code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"1"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_ok</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">unwrap</code><code class="p">(),</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="mi">1</code><code class="p">]);</code><code class="w"/>

<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"01"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_ok</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">unwrap</code><code class="p">(),</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="mi">1</code><code class="p">]);</code><code class="w"/>

<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"1,3"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_ok</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">unwrap</code><code class="p">(),</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="o">..</code><code class="mi">3</code><code class="p">]);</code><code class="w"/>

<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"001,0003"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_ok</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">unwrap</code><code class="p">(),</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="o">..</code><code class="mi">3</code><code class="p">]);</code><code class="w"/>

<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"1-3"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_ok</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">unwrap</code><code class="p">(),</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="mi">3</code><code class="p">]);</code><code class="w"/>

<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"0001-03"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_ok</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">unwrap</code><code class="p">(),</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="mi">3</code><code class="p">]);</code><code class="w"/>

<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"1,7,3-5"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_ok</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">unwrap</code><code class="p">(),</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="o">..</code><code class="mi">7</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="o">..</code><code class="mi">5</code><code class="p">]);</code><code class="w"/>

<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">res</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">(</code><code class="s">"15,19-20"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">is_ok</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">res</code><code class="p">.</code><code class="n">unwrap</code><code class="p">(),</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[</code><code class="mi">14</code><code class="o">..</code><code class="mi">15</code><code class="p">,</code><code class="w"> </code><code class="mi">18</code><code class="o">..</code><code class="mi">20</code><code class="p">]);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Some of the preceding tests check for a specific error message to help you write the <code>parse_pos</code> function; however, these could prove troublesome if you were trying to internationalize the error messages.<a data-primary="errors" data-secondary="error messages for cutr utility, parse_pos function" data-type="indexterm" id="id1024"/>
An alternative way to check for specific errors would be to use <code>enum</code> variants that would allow the user interface to customize the output while still testing for specific errors.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>At this point, I expect you can read the preceding code well enough to understand how the function should work. I recommend you stop reading at this point and write the code that will pass this test.</p>
</div>

<p>After <strong><code>cargo test unit</code></strong> passes, incorporate the <code>parse_pos</code> function into <code>run</code> so that your<a data-primary="parse_pos function" data-secondary="incorporating into run function" data-type="indexterm" id="id1025"/><a data-primary="run function" data-secondary="cutr utility" data-tertiary="incorporating parse_pos in" data-type="indexterm" id="id1026"/> program will reject invalid arguments and print an error message like the 
<span class="keep-together">following</span>:</p>

<pre data-type="programlisting">$ cargo run -- -f foo,bar tests/inputs/books.tsv
illegal list value: "foo"</pre>

<p>The program should also reject invalid ranges:</p>

<pre data-type="programlisting">$ cargo run -- -f 3-2 tests/inputs/books.tsv
First number in range (3) must be lower than second number (2)</pre>

<p>When given valid arguments, your program should be able to print the <code>Extract</code> argument like so:</p>

<pre data-type="programlisting">$ cargo run -- -f 4-8 tests/inputs/movies1.csv <a class="co" href="#callout_shave_and_a_haircut_CO12-1" id="co_shave_and_a_haircut_CO12-1"><img alt="1" src="assets/1.png"/></a>
Fields([3..8])</pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_shave_and_a_haircut_CO12-1" id="callout_shave_and_a_haircut_CO12-1"><img alt="1" src="assets/1.png"/></a></dt>
<dd><p>The <code>-f 4-8</code> one-based input creates the <code>Extract::Fields</code> variant that holds a single range of zero-offset numbers, <code>3..8</code>.<a data-primary="Extract::Fields" data-type="indexterm" id="id1027"/></p></dd>
</dl>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Stop here and get your program working as described. The program should be able to pass all the tests that validate the inputs, which you can run with <strong><code>cargo test dies</code></strong>:</p>

<pre data-type="programlisting">running 10 tests
test dies_bad_delimiter ... ok
test dies_chars_fields ... ok
test dies_chars_bytes_fields ... ok
test dies_bytes_fields ... ok
test dies_chars_bytes ... ok
test dies_not_enough_args ... ok
test dies_empty_delimiter ... ok
test dies_bad_digit_field ... ok
test dies_bad_digit_bytes ... ok
test dies_bad_digit_chars ... ok</pre>
</div>

<p>If you find you need more guidance on writing the <code>parse_pos</code> function, I’ll provide that in the next section.<a data-primary="cut utility" data-secondary="writing cutr version" data-startref="ix_cutwrreqprs" data-tertiary="requirements for parsing position list" data-type="indexterm" id="id1028"/></p>
</div></section>








<section data-pdf-bookmark="Solution for Parsing the Position List" data-type="sect2"><div class="sect2" id="id81">
<h2>Solution for Parsing the Position List</h2>

<p>The <code>parse_pos</code> function I will show <a data-primary="cut utility" data-secondary="writing cutr version" data-tertiary="parsing the position list" data-type="indexterm" id="ix_cutwrprsPL"/><a data-primary="ranges" data-secondary="parsing and validating in cutr" data-type="indexterm" id="ix_rngprsval"/>relies on a <code>parse_index</code> function that attempts to parse a string into a positive index value one less than the given number, because the user will provide one-based values but Rust needs zero-offset indexes.<a data-primary="indexes" data-secondary="parse_index function" data-type="indexterm" id="id1029"/>
The given string may not start with a plus sign, and the parsed value must be greater than zero.<a data-primary="|| (pipes)" data-secondary="arguments within, closures and" data-type="indexterm" id="id1030"/>
Note that closures normally accept arguments inside pipes (<code>||</code>), but the following function uses two closures that accept no arguments, which is why the pipes are empty.<a data-primary="closures" data-secondary="arguments within || (pipes)" data-type="indexterm" id="id1031"/>
Both closures instead reference the provided <code>input</code> value.<a data-primary="anyhow::anyhow macro" data-type="indexterm" id="id1032"/>
For the following code, be sure to use <code>anyhow::anyhow</code> and <code>std::num::NonZeroUsize</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code><code> </code><code class="nf">parse_index</code><code class="p">(</code><code class="n">input</code><code>:</code><code> </code><code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code><code>-&gt;</code><code> </code><code class="nb">Result</code><code class="o">&lt;</code><code class="kt">usize</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">value_error</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">|</code><code class="o">|</code><code class="w"> </code><code class="n">anyhow</code><code class="o">!</code><code class="p">(</code><code class="s">r#"illegal list value: "{input}""#</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO13-1" id="co_shave_and_a_haircut_CO13-1"><img alt="1" src="assets/1.png"/></a><code class="w">
    </code><code class="n">input</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">starts_with</code><code class="p">(</code><code class="sc">'+'</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO13-2" id="co_shave_and_a_haircut_CO13-2"><img alt="2" src="assets/2.png"/></a><code class="w">
        </code><code class="p">.</code><code class="n">then</code><code class="p">(</code><code class="o">|</code><code class="o">|</code><code class="w"> </code><code class="nb">Err</code><code class="p">(</code><code class="n">value_error</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO13-3" id="co_shave_and_a_haircut_CO13-3"><img alt="3" src="assets/3.png"/></a><code class="w">
        </code><code class="p">.</code><code class="n">unwrap_or_else</code><code class="p">(</code><code class="o">|</code><code class="o">|</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO13-4" id="co_shave_and_a_haircut_CO13-4"><img alt="4" src="assets/4.png"/></a><code class="w">
            </code><code class="n">input</code><code class="w">
</code><code class="w">                </code><code class="p">.</code><code class="n">parse</code><code>:</code><code>:</code><code class="o">&lt;</code><code class="n">NonZeroUsize</code><code class="o">&gt;</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO13-5" id="co_shave_and_a_haircut_CO13-5"><img alt="5" src="assets/5.png"/></a><code class="w">
                </code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">n</code><code class="o">|</code><code class="w"> </code><code class="kt">usize</code><code>::</code><code class="n">from</code><code class="p">(</code><code class="n">n</code><code class="p">)</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="mi">1</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO13-6" id="co_shave_and_a_haircut_CO13-6"><img alt="6" src="assets/6.png"/></a><code class="w">
                </code><code class="p">.</code><code class="n">map_err</code><code class="p">(</code><code class="o">|</code><code class="n">_</code><code class="o">|</code><code class="w"> </code><code class="n">value_error</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO13-7" id="co_shave_and_a_haircut_CO13-7"><img alt="7" src="assets/7.png"/></a><code class="w">
        </code><code class="p">}</code><code class="p">)</code><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_shave_and_a_haircut_CO13-1" id="callout_shave_and_a_haircut_CO13-1"><img alt="1" src="assets/1.png"/></a></dt>
<dd><p>Create a closure that accepts no arguments and formats an error string.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO13-2" id="callout_shave_and_a_haircut_CO13-2"><img alt="2" src="assets/2.png"/></a></dt>
<dd><p>Check if the input value starts with a plus sign.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO13-3" id="callout_shave_and_a_haircut_CO13-3"><img alt="3" src="assets/3.png"/></a></dt>
<dd><p>If so, create an error.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO13-4" id="callout_shave_and_a_haircut_CO13-4"><img alt="4" src="assets/4.png"/></a></dt>
<dd><p>Otherwise, continue with the following closure, which accepts no arguments.<a data-primary="str::parse function" data-type="indexterm" id="id1033"/><a data-primary="usize type" data-type="indexterm" id="id1034"/></p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO13-5" id="callout_shave_and_a_haircut_CO13-5"><img alt="5" src="assets/5.png"/></a></dt>
<dd><p>Use <code>str::parse</code> to parse the input value, and use the turbofish to indicate the return type of <a href="https://oreil.ly/ec44d"><code>std::num::NonZeroUsize</code></a>, which is a positive integer value.<a data-primary="std::num::NonZeroUsize" data-type="indexterm" id="id1035"/></p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO13-6" id="callout_shave_and_a_haircut_CO13-6"><img alt="6" src="assets/6.png"/></a></dt>
<dd><p>If the input value parses successfully, cast the value to a <code>usize</code> and decrement the value to a zero-based offset.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO13-7" id="callout_shave_and_a_haircut_CO13-7"><img alt="7" src="assets/7.png"/></a></dt>
<dd><p>If the value does not parse, generate an error by calling the <code>value_error</code> closure.<a data-primary="value_error closure" data-type="indexterm" id="id1036"/></p></dd>
</dl>

<p>The following is how <code>parse_index</code> is used in the <code>parse_pos</code> function.
Add <code>use regex::Regex</code> to your imports<a data-primary="parse_index function, use in parse_pos" data-type="indexterm" id="id1037"/> for this:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code><code> </code><code class="nf">parse_pos</code><code class="p">(</code><code class="n">range</code><code>:</code><code> </code><code class="nb">String</code><code class="p">)</code><code class="w"> </code><code>-&gt;</code><code> </code><code class="nb">Result</code><code class="o">&lt;</code><code class="n">PositionList</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">range_re</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Regex</code><code>::</code><code class="n">new</code><code class="p">(</code><code class="s">r"^(\d+)-(\d+)$"</code><code class="p">)</code><code class="p">.</code><code class="n">unwrap</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO14-1" id="co_shave_and_a_haircut_CO14-1"><img alt="1" src="assets/1.png"/></a><code class="w">
    </code><code class="n">range</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">split</code><code class="p">(</code><code class="sc">','</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO14-2" id="co_shave_and_a_haircut_CO14-2"><img alt="2" src="assets/2.png"/></a><code class="w">
        </code><code class="p">.</code><code class="n">into_iter</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">val</code><code class="o">|</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO14-3" id="co_shave_and_a_haircut_CO14-3"><img alt="3" src="assets/3.png"/></a><code class="w">
            </code><code class="n">parse_index</code><code class="p">(</code><code class="n">val</code><code class="p">)</code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">n</code><code class="o">|</code><code class="w"> </code><code class="n">n</code><code class="o">..</code><code class="n">n</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="p">)</code><code class="p">.</code><code class="n">or_else</code><code class="p">(</code><code class="o">|</code><code class="n">e</code><code class="o">|</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO14-4" id="co_shave_and_a_haircut_CO14-4"><img alt="4" src="assets/4.png"/></a><code class="w">
                </code><code class="n">range_re</code><code class="p">.</code><code class="n">captures</code><code class="p">(</code><code class="n">val</code><code class="p">)</code><code class="p">.</code><code class="n">ok_or</code><code class="p">(</code><code class="n">e</code><code class="p">)</code><code class="p">.</code><code class="n">and_then</code><code class="p">(</code><code class="o">|</code><code class="n">captures</code><code class="o">|</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO14-5" id="co_shave_and_a_haircut_CO14-5"><img alt="5" src="assets/5.png"/></a><code class="w">
                    </code><code class="kd">let</code><code class="w"> </code><code class="n">n1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_index</code><code class="p">(</code><code class="o">&amp;</code><code class="n">captures</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO14-6" id="co_shave_and_a_haircut_CO14-6"><img alt="6" src="assets/6.png"/></a><code class="w">
                    </code><code class="kd">let</code><code class="w"> </code><code class="n">n2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">parse_index</code><code class="p">(</code><code class="o">&amp;</code><code class="n">captures</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w">
</code><code class="w">                    </code><code class="k">if</code><code class="w"> </code><code class="n">n1</code><code class="w"> </code><code class="o">&gt;</code><code class="o">=</code><code class="w"> </code><code class="n">n2</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO14-7" id="co_shave_and_a_haircut_CO14-7"><img alt="7" src="assets/7.png"/></a><code class="w">
                        </code><code class="n">bail</code><code class="o">!</code><code class="p">(</code><code class="w">
</code><code class="w">                            </code><code class="s">"</code><code class="s">First number in range ({}) </code><code class="s">\</code><code class="s">
                            must be lower than second number ({})</code><code class="s">"</code><code class="p">,</code><code class="w">
</code><code class="w">                            </code><code class="n">n1</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w">
</code><code class="w">                            </code><code class="n">n2</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="w">
</code><code class="w">                        </code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">                    </code><code class="p">}</code><code class="w">
</code><code class="w">                    </code><code class="nb">Ok</code><code class="p">(</code><code class="n">n1</code><code class="o">..</code><code class="n">n2</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO14-8" id="co_shave_and_a_haircut_CO14-8"><img alt="8" src="assets/8.png"/></a><code class="w">
                </code><code class="p">}</code><code class="p">)</code><code class="w">
</code><code class="w">            </code><code class="p">}</code><code class="p">)</code><code class="w">
</code><code class="w">        </code><code class="p">}</code><code class="p">)</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">collect</code><code>:</code><code>:</code><code class="o">&lt;</code><code class="nb">Result</code><code class="o">&lt;</code><code class="n">_</code><code class="p">,</code><code class="w"> </code><code class="n">_</code><code class="o">&gt;</code><code class="o">&gt;</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO14-9" id="co_shave_and_a_haircut_CO14-9"><img alt="9" src="assets/9.png"/></a><code class="w">
        </code><code class="p">.</code><code class="n">map_err</code><code class="p">(</code><code class="nb">From</code><code>::</code><code class="n">from</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO14-10" id="co_shave_and_a_haircut_CO14-10"><img alt="10" src="assets/10.png"/></a><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_shave_and_a_haircut_CO14-1" id="callout_shave_and_a_haircut_CO14-1"><img alt="1" src="assets/1.png"/></a></dt>
<dd><p>Create a regular expression to match two integers separated by a dash, using parentheses to capture the matched numbers.<a data-primary="regular expressions" data-secondary="creating to match two integers separated by a dash" data-type="indexterm" id="id1038"/><a data-primary="() (parentheses)" data-secondary="capturing in regular expressions" data-type="indexterm" id="id1039"/></p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO14-2" id="callout_shave_and_a_haircut_CO14-2"><img alt="2" src="assets/2.png"/></a></dt>
<dd><p>Split the provided range value on the comma and turn the result into an iterator. In the event there are no commas, the provided value itself will be used.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO14-3" id="callout_shave_and_a_haircut_CO14-3"><img alt="3" src="assets/3.png"/></a></dt>
<dd><p>Map each split value into the closure.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO14-4" id="callout_shave_and_a_haircut_CO14-4"><img alt="4" src="assets/4.png"/></a></dt>
<dd><p>If <code>parse_index</code> parses a single number, then create a <code>Range</code> for the value. Otherwise, note the error value <code>e</code> and continue trying to parse a range.<a data-primary="Regex::captures" data-type="indexterm" id="id1040"/></p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO14-5" id="callout_shave_and_a_haircut_CO14-5"><img alt="5" src="assets/5.png"/></a></dt>
<dd><p>If the <code>Regex</code> matches the value, the numbers in parentheses will be available through <a href="https://oreil.ly/O6frw"><code>Regex::captures</code></a>.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO14-6" id="callout_shave_and_a_haircut_CO14-6"><img alt="6" src="assets/6.png"/></a></dt>
<dd><p>Parse the two captured numbers as index values.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO14-7" id="callout_shave_and_a_haircut_CO14-7"><img alt="7" src="assets/7.png"/></a></dt>
<dd><p>If the first value is greater than or equal to the second, return an error.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO14-8" id="callout_shave_and_a_haircut_CO14-8"><img alt="8" src="assets/8.png"/></a></dt>
<dd><p>Otherwise, create a <code>Range</code> from the lower number to the higher number, adding 1 to ensure the upper number is included.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO14-9" id="callout_shave_and_a_haircut_CO14-9"><img alt="9" src="assets/9.png"/></a></dt>
<dd><p>Use <a href="https://oreil.ly/Xn28H"><code>Iterator::collect</code></a> to gather the values as a <code>Result</code>.<a data-primary="Iterator::collect function" data-type="indexterm" id="id1041"/></p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO14-10" id="callout_shave_and_a_haircut_CO14-10"><img alt="10" src="assets/10.png"/></a></dt>
<dd><p>Map any problems through <a href="https://oreil.ly/sXlWa"><code>From::from</code></a> to create an error.<a data-primary="From::from function" data-type="indexterm" id="id1042"/></p></dd>
</dl>

<p class="pagebreak-after">The regular expression in the preceding code is represented using a raw string to prevent Rust from interpreting backslash-escaped values in the string.<a data-primary="raw strings" data-type="indexterm" id="id1043"/><a data-primary="strings" data-secondary="raw, in regular expressions" data-type="indexterm" id="id1044"/>
For instance, you’ve seen that Rust will interpret <code>\n</code> as a newline.
Without this, the compiler complains that <code>\d</code> is an <em>unknown character escape</em>:</p>

<pre data-type="programlisting">error: unknown character escape: `d`
   --&gt; src/main.rs:146:35
    |
146 |     let range_re = Regex::new("^(\d+)-(\d+)$").unwrap();
    |                                   ^ unknown character escape
    |
    = help: for more information, visit
    &lt;https://doc.rust-lang.org/reference/tokens.html#literals&gt;
help: if you meant to write a literal backslash (perhaps escaping in a
regular expression), consider a raw string literal</pre>

<p>I would like to highlight the<a data-primary="() (parentheses)" data-secondary="capturing in regular expressions" data-type="indexterm" id="id1045"/> parentheses in the regular expression <code>^(\d+)-(\d+)$</code> to indicate one or more digits followed by a dash followed by one or more digits, as shown in <a data-type="xref" href="#fig_8.1">Figure 8-1</a>.
If the regular expression matches the given string, then I can use <code>Regex::captures</code> to extract the digits that are surrounded by the parentheses.<a data-primary="Regex::captures" data-type="indexterm" id="id1046"/>
Note that they are available in one-based counting, so the contents of the first capturing parentheses are available in position <code>1</code> of the captures.</p>

<figure><div class="figure" id="fig_8.1">
<img alt="clru 0801" src="assets/clru_0801.png"/>
<h6><span class="label">Figure 8-1. </span>The parentheses in the regular expression will capture the values they 
<span class="keep-together">surround.</span></h6>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Now that you have a way to parse and validate the numeric ranges, incorporate this into your <code>run</code> function to transform your 
<span class="keep-together"><code>ArgsExtract</code></span> into an <code>Extract</code> enum before reading further.<a data-primary="Extract enum" data-type="indexterm" id="id1047"/><a data-primary="ArgsExtract struct" data-secondary="transforming into Extract enum" data-type="indexterm" id="id1048"/><a data-primary="ranges" data-secondary="parsing and validating in cutr" data-startref="ix_rngprsval" data-type="indexterm" id="id1049"/></p>
</div>

<p>Following is how I incorporate the <code>parse_pos</code> function<a data-primary="get_args function" data-secondary="cutr utility" data-tertiary="incorporating parse_pos in" data-type="indexterm" id="id1050"/><a data-primary="parse_pos function" data-secondary="incorporating into get_args function" data-type="indexterm" id="id1051"/> into my <code>run</code> to figure out which <code>Extract</code> variant to create or generate an error if the user fails<a data-primary="fields, bytes, or characters, extracting" data-type="indexterm" id="id1052"/><a data-primary="extracting bytes, characters, or fields" data-type="indexterm" id="id1053"/> to select bytes, characters, or fields:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code><code> </code><code class="nf">run</code><code class="p">(</code><code class="n">args</code><code>:</code><code> </code><code class="nc">Args</code><code class="p">)</code><code class="w"> </code><code>-&gt;</code><code> </code><code class="nb">Result</code><code class="o">&lt;</code><code class="p">(</code><code class="p">)</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="c1">// Same as before
</code><code class="w">
</code><code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">extract</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">fields</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w">
</code><code class="w">        </code><code class="n">args</code><code class="p">.</code><code class="n">extract</code><code class="p">.</code><code class="n">fields</code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="n">parse_pos</code><code class="p">)</code><code class="p">.</code><code class="n">transpose</code><code class="p">(</code><code class="p">)</code><code class="o">?</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO15-1" id="co_shave_and_a_haircut_CO15-1"><img alt="1" src="assets/1.png"/></a><code class="w">
    </code><code class="p">{</code><code class="w">
</code><code class="w">        </code><code class="n">Extract</code><code>::</code><code class="n">Fields</code><code class="p">(</code><code class="n">fields</code><code class="p">)</code><code class="w">
</code><code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">bytes</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w">
</code><code class="w">        </code><code class="n">args</code><code class="p">.</code><code class="n">extract</code><code class="p">.</code><code class="n">bytes</code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="n">parse_pos</code><code class="p">)</code><code class="p">.</code><code class="n">transpose</code><code class="p">(</code><code class="p">)</code><code class="o">?</code><code class="w">
</code><code class="w">    </code><code class="p">{</code><code class="w">
</code><code class="w">        </code><code class="n">Extract</code><code>::</code><code class="n">Bytes</code><code class="p">(</code><code class="n">bytes</code><code class="p">)</code><code class="w">
</code><code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">chars</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w">
</code><code class="w">        </code><code class="n">args</code><code class="p">.</code><code class="n">extract</code><code class="p">.</code><code class="n">chars</code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="n">parse_pos</code><code class="p">)</code><code class="p">.</code><code class="n">transpose</code><code class="p">(</code><code class="p">)</code><code class="o">?</code><code class="w">
</code><code class="w">    </code><code class="p">{</code><code class="w">
</code><code class="w">        </code><code class="n">Extract</code><code>::</code><code class="n">Chars</code><code class="p">(</code><code class="n">chars</code><code class="p">)</code><code class="w">
</code><code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">        </code><code class="fm">unreachable!</code><code class="p">(</code><code class="s">"</code><code class="s">Must have --fields, --bytes, or --chars</code><code class="s">"</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO15-2" id="co_shave_and_a_haircut_CO15-2"><img alt="2" src="assets/2.png"/></a><code class="w">
    </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"</code><code class="s">{extract:?}</code><code class="s">"</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">    </code><code class="nb">Ok</code><code class="p">(</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_shave_and_a_haircut_CO15-1" id="callout_shave_and_a_haircut_CO15-1"><img alt="1" src="assets/1.png"/></a></dt>
<dd><p>Attempt to call <code>parse_pos</code> through <a href="https://oreil.ly/DOpks"><code>Option::map</code></a> on <code>args.extract.fields</code>, using <a href="https://oreil.ly/HIxb_"><code>Result::transpose</code></a> to turn the <code>Result</code> of an <code>Option</code> into an <code>Option</code> of a <code>Result</code>.<a data-primary="Result::transpose function" data-type="indexterm" id="id1054"/><a data-primary="Option type" data-secondary="turning Result of Option into Option of Result" data-type="indexterm" id="id1055"/></p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO15-2" id="callout_shave_and_a_haircut_CO15-2"><img alt="2" src="assets/2.png"/></a></dt>
<dd><p>Logically, this line should never be executed, so call the <a href="https://oreil.ly/pwSIv"><code>unreachable!</code></a> macro to cause a panic.<a data-primary="unreachable! macro" data-type="indexterm" id="id1056"/></p></dd>
</dl>

<p>Next, you will need to figure out how you will use this information to extract the desired bits from the inputs.<a data-primary="cut utility" data-secondary="writing cutr version" data-startref="ix_cutwrprsPL" data-tertiary="parsing the position list" data-type="indexterm" id="id1057"/></p>
</div></section>








<section data-pdf-bookmark="Extracting Characters or Bytes" data-type="sect2"><div class="sect2" id="id82">
<h2>Extracting Characters or Bytes</h2>

<p>In Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch04.html#ch04">4</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch05.html#ch05">5</a>, you learned how to process lines, bytes, and characters in a file.<a data-primary="cut utility" data-secondary="writing cutr version" data-tertiary="extracting characters or bytes" data-type="indexterm" id="ix_cutwrextchby"/><a data-primary="extracting bytes, characters, or fields" data-secondary="extracting characters or bytes" data-type="indexterm" id="ix_extrchby"/>
You should draw on those programs to help you select characters and bytes in this challenge.<a data-primary="BufRead::lines function" data-type="indexterm" id="id1058"/><a data-primary="open function" data-type="indexterm" id="id1059"/>
One difference is that line endings need not be preserved, so you may use <a href="https://oreil.ly/KhmCp"><code>BufRead::lines</code></a> to read the lines of input text.
To start, you might consider bringing in the <code>open</code> function to open each file:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">open</code><code class="p">(</code><code class="n">filename</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="nb">Box</code><code class="o">&lt;</code><code class="k">dyn</code><code class="w"> </code><code class="n">BufRead</code><code class="o">&gt;&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">match</code><code class="w"> </code><code class="n">filename</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="s">"-"</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">Ok</code><code class="p">(</code><code class="nb">Box</code>::<code class="n">new</code><code class="p">(</code><code class="n">BufReader</code>::<code class="n">new</code><code class="p">(</code><code class="n">io</code>::<code class="n">stdin</code><code class="p">()))),</code><code class="w"/>
<code class="w">        </code><code class="n">_</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">Ok</code><code class="p">(</code><code class="nb">Box</code>::<code class="n">new</code><code class="p">(</code><code class="n">BufReader</code>::<code class="n">new</code><code class="p">(</code><code class="n">File</code>::<code class="n">open</code><code class="p">(</code><code class="n">filename</code><code class="p">)</code><code class="o">?</code><code class="p">))),</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The preceding function will require some additional imports from the <code>std</code> 
<span class="keep-together">namespace</span>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">fs</code>::<code class="n">File</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">io</code>::<code class="p">{</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">BufRead</code><code class="p">,</code><code class="w"> </code><code class="n">BufReader</code><code class="p">},</code><code class="w"/>
<code class="w">    </code><code class="n">num</code>::<code class="n">NonZeroUsize</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">ops</code>::<code class="n">Range</code><code class="p">,</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>

<p class="pagebreak-before">You can expand your <code>run</code> to handle good and bad files:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">run</code><code class="p">(</code><code class="n">args</code>: <code class="nc">Args</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="p">()</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// Same as before</code>

<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">filename</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="o">&amp;</code><code class="n">args</code><code class="p">.</code><code class="n">files</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">match</code><code class="w"> </code><code class="n">open</code><code class="p">(</code><code class="n">filename</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nb">Err</code><code class="p">(</code><code class="n">err</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="fm">eprintln!</code><code class="p">(</code><code class="s">"{filename}: {err}"</code><code class="p">),</code><code class="w"/>
<code class="w">            </code><code class="nb">Ok</code><code class="p">(</code><code class="n">_</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="fm">println!</code><code class="p">(</code><code class="s">"Opened {filename}"</code><code class="p">),</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nb">Ok</code><code class="p">(())</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>At this point, the program should pass <strong><code>cargo test skips_bad_file</code></strong>, and you can manually verify that it skips invalid files such as the nonexistent <em>blargh</em>:</p>

<pre data-type="programlisting">$ cargo run -- -c 1 tests/inputs/books.csv <strong>blargh</strong>
Opened tests/inputs/books.csv
<strong>blargh: No such file or directory (os error 2)</strong></pre>

<p>Now consider how you might extract ranges of characters from each line of a filehandle.<a data-primary="characters" data-secondary="extracting" data-type="indexterm" id="id1060"/>
I wrote a function called <code>extract_chars</code> that will return a new string composed of the characters at the given index positions:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">extract_chars</code><code class="p">(</code><code class="n">line</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">,</code><code class="w"> </code><code class="n">char_pos</code>: <code class="kp">&amp;</code><code class="p">[</code><code class="n">Range</code><code class="o">&lt;</code><code class="kt">usize</code><code class="o">&gt;</code><code class="p">])</code><code class="w"> </code>-&gt; <code class="nb">String</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="fm">unimplemented!</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>I originally wrote the preceding function with the type annotation <code>&amp;PositionList</code> 
<span class="keep-together">for <code>char_pos</code>,</span> but the type <code>&amp;[Range&lt;usize&gt;]</code> is more flexible for callers, especially for writing tests.</p>
</div>

<p>The following is a test you can add to the <code>unit_tests</code> module.
Be sure to add <code>extract_chars</code> to the module’s imports:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[test]</code><code class="w"/>
<code class="k">fn</code> <code class="nf">test_extract_chars</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">extract_chars</code><code class="p">(</code><code class="s">""</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="mi">1</code><code class="p">]),</code><code class="w"> </code><code class="s">""</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">    </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">extract_chars</code><code class="p">(</code><code class="s">"ábc"</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="mi">1</code><code class="p">]),</code><code class="w"> </code><code class="s">"á"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">    </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">extract_chars</code><code class="p">(</code><code class="s">"ábc"</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="o">..</code><code class="mi">3</code><code class="p">]),</code><code class="w"> </code><code class="s">"ác"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">    </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">extract_chars</code><code class="p">(</code><code class="s">"ábc"</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="mi">3</code><code class="p">]),</code><code class="w"> </code><code class="s">"ábc"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">    </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">extract_chars</code><code class="p">(</code><code class="s">"ábc"</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="mi">2</code><code class="o">..</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="o">..</code><code class="mi">2</code><code class="p">]),</code><code class="w"> </code><code class="s">"cb"</code><code class="p">.</code><code class="n">to_string</code><code class="p">());</code><code class="w"/>
<code class="w">    </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="w"/>
<code class="w">        </code><code class="n">extract_chars</code><code class="p">(</code><code class="s">"ábc"</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="o">..</code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="o">..</code><code class="mi">5</code><code class="p">]),</code><code class="w"/>
<code class="w">        </code><code class="s">"áb"</code><code class="p">.</code><code class="n">to_string</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p class="pagebreak-before">I also wrote a similar <code>extract_bytes</code> function <a data-primary="bytes" data-secondary="extracting" data-type="indexterm" id="id1061"/>to parse out bytes:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">extract_bytes</code><code class="p">(</code><code class="n">line</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">,</code><code class="w"> </code><code class="n">byte_pos</code>: <code class="kp">&amp;</code><code class="p">[</code><code class="n">Range</code><code class="o">&lt;</code><code class="kt">usize</code><code class="o">&gt;</code><code class="p">])</code><code class="w"> </code>-&gt; <code class="nb">String</code> <code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="fm">unimplemented!</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>For the following unit test, be sure to add <code>extract_bytes</code> to the module’s imports:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[</code><code class="cp">test</code><code class="cp">]</code><code class="w">
</code><code class="k">fn</code><code> </code><code class="nf">test_extract_bytes</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">extract_bytes</code><code class="p">(</code><code class="s">"</code><code class="s">ábc</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="mi">1</code><code class="p">]</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">�</code><code class="s">"</code><code class="p">.</code><code class="n">to_string</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO16-1" id="co_shave_and_a_haircut_CO16-1"><img alt="1" src="assets/1.png"/></a><code class="w">
    </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">extract_bytes</code><code class="p">(</code><code class="s">"</code><code class="s">ábc</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="mi">2</code><code class="p">]</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">á</code><code class="s">"</code><code class="p">.</code><code class="n">to_string</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">    </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">extract_bytes</code><code class="p">(</code><code class="s">"</code><code class="s">ábc</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="mi">3</code><code class="p">]</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">áb</code><code class="s">"</code><code class="p">.</code><code class="n">to_string</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">    </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">extract_bytes</code><code class="p">(</code><code class="s">"</code><code class="s">ábc</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="mi">4</code><code class="p">]</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">ábc</code><code class="s">"</code><code class="p">.</code><code class="n">to_string</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">    </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">extract_bytes</code><code class="p">(</code><code class="s">"</code><code class="s">ábc</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="mi">3</code><code class="o">..</code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="o">..</code><code class="mi">3</code><code class="p">]</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">cb</code><code class="s">"</code><code class="p">.</code><code class="n">to_string</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">    </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">extract_bytes</code><code class="p">(</code><code class="s">"</code><code class="s">ábc</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="o">..</code><code class="mi">6</code><code class="p">]</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="s">"</code><code class="s">á</code><code class="s">"</code><code class="p">.</code><code class="n">to_string</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_shave_and_a_haircut_CO16-1" id="callout_shave_and_a_haircut_CO16-1"><img alt="1" src="assets/1.png"/></a></dt>
<dd><p>Note that selecting one byte from the string <em>ábc</em> should break the multibyte <em>á</em> and result in the Unicode replacement character.</p></dd>
</dl>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Once you have written these two functions so that they pass tests, incorporate them into your main program so that you pass the integration tests for printing bytes and characters. The failing tests that include <em>tsv</em> and <em>csv</em> in the names involve reading text delimited by tabs and commas, which I’ll discuss in the next section.<a data-primary="cut utility" data-secondary="writing cutr version" data-startref="ix_cutwrextchby" data-tertiary="extracting characters or bytes" data-type="indexterm" id="id1062"/><a data-primary="extracting bytes, characters, or fields" data-secondary="extracting characters or bytes" data-startref="ix_extrchby" data-type="indexterm" id="id1063"/></p>
</div>
</div></section>








<section data-pdf-bookmark="Parsing Delimited Text Files" data-type="sect2"><div class="sect2" id="id83">
<h2>Parsing Delimited Text Files</h2>

<p>Next, you will need to learn how to parse delimited text files.<a data-primary="delimited text files, parsing" data-type="indexterm" id="ix_deltxtfi"/><a data-primary="cut utility" data-secondary="writing cutr version" data-tertiary="parsing delimited text files" data-type="indexterm" id="ix_cutwrprsdeltxt"/>
Technically, all the files you’ve read to this point were delimited in some manner, such as with newlines to denote the end of a line.
In this case, a delimiter like a tab or a comma is used to separate the fields of a record, which is terminated with a newline.
Sometimes the delimiting character may also be part of the data, as when the title <em>20,000 Leagues Under the Sea</em> occurs in a CSV file.<a data-primary="&quot; &quot; (quotation marks, double)" data-secondary="escaping delimiters" data-type="indexterm" id="id1064"/>
In this case, the field should be enclosed in quotes to escape the delimiter.
As noted in the chapter’s introduction, neither the BSD nor the GNU version of <code>cut</code> respects this escaped delimiter, but the challenge program will.
The easiest way to properly parse delimited text is to use something like the <code>csv</code> crate.<a data-primary="csv crate" data-type="indexterm" id="id1065"/>
I highly recommend that you first read the <a href="https://oreil.ly/Wcapp">tutorial</a>, which explains the basics of working with delimited text files and how to use the <code>csv</code> module effectively.</p>

<p>Consider the following example that shows how you can use this crate to parse delimited data.
If you would like to compile and run this code, start a new project, add the <code>csv = "1.3.0"</code> dependency to your <em>Cargo.toml</em>, and copy the <em>tests/inputs​/⁠books.csv</em> file into the root directory of the new project.
Use the following for <em>src​/⁠main.rs</em>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">use</code><code class="w"> </code><code class="n">csv</code><code>:</code><code>:</code><code class="p">{</code><code class="n">ReaderBuilder</code><code class="p">,</code><code class="w"> </code><code class="n">StringRecord</code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="k">use</code><code class="w"> </code><code class="n">std</code><code>::</code><code class="n">fs</code><code>::</code><code class="n">File</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="k">fn</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code>-&gt;</code><code> </code><code class="nc">std</code><code>::</code><code class="n">io</code><code>::</code><code class="nb">Result</code><code class="o">&lt;</code><code class="p">(</code><code class="p">)</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">reader</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">ReaderBuilder</code><code>::</code><code class="n">new</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO17-1" id="co_shave_and_a_haircut_CO17-1"><img alt="1" src="assets/1.png"/></a><code class="w">
        </code><code class="p">.</code><code class="n">delimiter</code><code class="p">(</code><code class="sc">b','</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO17-2" id="co_shave_and_a_haircut_CO17-2"><img alt="2" src="assets/2.png"/></a><code class="w">
        </code><code class="p">.</code><code class="n">from_reader</code><code class="p">(</code><code class="n">File</code><code>::</code><code class="n">open</code><code class="p">(</code><code class="s">"</code><code class="s">books.csv</code><code class="s">"</code><code class="p">)</code><code class="o">?</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO17-3" id="co_shave_and_a_haircut_CO17-3"><img alt="3" src="assets/3.png"/></a><code class="w">

    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"</code><code class="s">{}</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">fmt</code><code class="p">(</code><code class="n">reader</code><code class="p">.</code><code class="n">headers</code><code class="p">(</code><code class="p">)</code><code class="o">?</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO17-4" id="co_shave_and_a_haircut_CO17-4"><img alt="4" src="assets/4.png"/></a><code class="w">
    </code><code class="k">for</code><code class="w"> </code><code class="n">record</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">reader</code><code class="p">.</code><code class="n">records</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO17-5" id="co_shave_and_a_haircut_CO17-5"><img alt="5" src="assets/5.png"/></a><code class="w">
        </code><code class="fm">println!</code><code class="p">(</code><code class="s">"</code><code class="s">{}</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">fmt</code><code class="p">(</code><code class="o">&amp;</code><code class="n">record</code><code class="o">?</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO17-6" id="co_shave_and_a_haircut_CO17-6"><img alt="6" src="assets/6.png"/></a><code class="w">
    </code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="w">    </code><code class="nb">Ok</code><code class="p">(</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="w">
</code><code class="p">}</code><code class="w">
</code><code class="w">
</code><code class="k">fn</code><code> </code><code class="nf">fmt</code><code class="p">(</code><code class="n">rec</code><code>:</code><code> </code><code class="kp">&amp;</code><code class="nc">StringRecord</code><code class="p">)</code><code class="w"> </code><code>-&gt;</code><code> </code><code class="nb">String</code><code> </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="n">rec</code><code class="p">.</code><code class="n">into_iter</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">v</code><code class="o">|</code><code class="w"> </code><code class="fm">format!</code><code class="p">(</code><code class="s">"</code><code class="s">{:20}</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">v</code><code class="p">)</code><code class="p">)</code><code class="p">.</code><code class="n">collect</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO17-7" id="co_shave_and_a_haircut_CO17-7"><img alt="7" src="assets/7.png"/></a><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_shave_and_a_haircut_CO17-1" id="callout_shave_and_a_haircut_CO17-1"><img alt="1" src="assets/1.png"/></a></dt>
<dd><p>Use <a href="https://oreil.ly/aJ-kp"><code>csv::ReaderBuilder</code></a> to parse a file.<a data-primary="csv::ReaderBuilder" data-type="indexterm" id="id1066"/><a data-primary="delimiters" data-secondary="delimiter as u8 byte" data-type="indexterm" id="id1067"/></p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO17-2" id="callout_shave_and_a_haircut_CO17-2"><img alt="2" src="assets/2.png"/></a></dt>
<dd><p>The <a href="https://oreil.ly/cDuGF"><code>delimiter</code></a> must be a single <code>u8</code> byte.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO17-3" id="callout_shave_and_a_haircut_CO17-3"><img alt="3" src="assets/3.png"/></a></dt>
<dd><p>The <a href="https://oreil.ly/nHl5R"><code>from_reader</code> method</a> accepts a value that implements the <a href="https://oreil.ly/wDxvY"><code>Read</code> trait</a>.<a data-primary="from_reader method" data-type="indexterm" id="id1068"/><a data-primary="Read trait" data-type="indexterm" id="id1069"/><a data-primary="Reader::headers method" data-type="indexterm" id="id1070"/></p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO17-4" id="callout_shave_and_a_haircut_CO17-4"><img alt="4" src="assets/4.png"/></a></dt>
<dd><p>The <a href="https://oreil.ly/BtSg8"><code>Reader::headers</code> method</a> will return the column names in the first row as a <a href="https://oreil.ly/7UOCm"><code>StringRecord</code></a>.<a data-primary="StringRecord type" data-type="indexterm" id="id1071"/><a data-primary="Reader::records method" data-type="indexterm" id="id1072"/></p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO17-5" id="callout_shave_and_a_haircut_CO17-5"><img alt="5" src="assets/5.png"/></a></dt>
<dd><p>The <a href="https://oreil.ly/SDfZC"><code>Reader::records</code> method</a> provides access to an iterator over <code>StringRecord</code> values.<a data-primary="Iterator::map function" data-type="indexterm" id="id1073"/></p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO17-6" id="callout_shave_and_a_haircut_CO17-6"><img alt="6" src="assets/6.png"/></a></dt>
<dd><p>Print a formatted version of the record.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO17-7" id="callout_shave_and_a_haircut_CO17-7"><img alt="7" src="assets/7.png"/></a></dt>
<dd><p>Use <a href="https://oreil.ly/cfevE"><code>Iterator::map</code></a> to format the values into fields 20 characters wide and collect the values into a new <code>String</code>.</p></dd>
</dl>

<p>If you run this program, you will see that the comma in <em>20,000 Leagues Under the Sea</em> was not used as a field delimiter because it was found within quotes, which themselves are metacharacters that have been removed:</p>

<pre data-type="programlisting">$ cargo run
Author              Year                Title
Émile Zola          1865                La Confession de Claude
Samuel Beckett      1952                Waiting for Godot
Jules Verne         1870                20,000 Leagues Under the Sea</pre>
<div data-type="tip"><h6>Tip</h6>
<p>In addition to <code>csv::ReaderBuilder</code>, you should use <a href="https://oreil.ly/uXNbn"><code>csv::WriterBuilder</code></a> in your solution to escape the input delimiter in the output of the program.<a data-primary="csv::WriterBuilder" data-type="indexterm" id="id1074"/></p>
</div>

<p>Think about how you might use some of the ideas I just demonstrated in your challenge program.<a data-primary="csv::StringRecord" data-type="indexterm" id="id1075"/><a data-primary="PositionList type alias" data-type="indexterm" id="id1076"/>
For example, you could write a function like <code>extract_fields</code> that accepts a <code>csv::StringRecord</code> and pulls out the fields found in the <code>PositionList</code>.
For the following function, add <code>use csv::StringRecord</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">extract_fields</code><code class="p">(</code><code class="w"/>
<code class="w">    </code><code class="n">record</code>: <code class="kp">&amp;</code><code class="nc">StringRecord</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">field_pos</code>: <code class="kp">&amp;</code><code class="p">[</code><code class="n">Range</code><code class="o">&lt;</code><code class="kt">usize</code><code class="o">&gt;</code><code class="p">]</code><code class="w"/>
<code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Vec</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="fm">unimplemented!</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Following is a unit test for this <a data-primary="unit tests" data-secondary="test for extract_fields function" data-type="indexterm" id="id1077"/>function that you can add to the <code>unit_tests</code> module:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[test]</code><code class="w"/>
<code class="k">fn</code> <code class="nf">test_extract_fields</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">rec</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">StringRecord</code>::<code class="n">from</code><code class="p">(</code><code class="fm">vec!</code><code class="p">[</code><code class="s">"Captain"</code><code class="p">,</code><code class="w"> </code><code class="s">"Sham"</code><code class="p">,</code><code class="w"> </code><code class="s">"12345"</code><code class="p">]);</code><code class="w"/>
<code class="w">    </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">extract_fields</code><code class="p">(</code><code class="o">&amp;</code><code class="n">rec</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="mi">1</code><code class="p">]),</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="s">"Captain"</code><code class="p">]);</code><code class="w"/>
<code class="w">    </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">extract_fields</code><code class="p">(</code><code class="o">&amp;</code><code class="n">rec</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="mi">1</code><code class="o">..</code><code class="mi">2</code><code class="p">]),</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="s">"Sham"</code><code class="p">]);</code><code class="w"/>
<code class="w">    </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="w"/>
<code class="w">        </code><code class="n">extract_fields</code><code class="p">(</code><code class="o">&amp;</code><code class="n">rec</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="o">..</code><code class="mi">3</code><code class="p">]),</code><code class="w"/>
<code class="w">        </code><code class="o">&amp;</code><code class="p">[</code><code class="s">"Captain"</code><code class="p">,</code><code class="w"> </code><code class="s">"12345"</code><code class="p">]</code><code class="w"/>
<code class="w">    </code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">extract_fields</code><code class="p">(</code><code class="o">&amp;</code><code class="n">rec</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="o">..</code><code class="mi">4</code><code class="p">]),</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="s">"Captain"</code><code class="p">]);</code><code class="w"/>
<code class="w">    </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">extract_fields</code><code class="p">(</code><code class="o">&amp;</code><code class="n">rec</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="mi">1</code><code class="o">..</code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="o">..</code><code class="mi">1</code><code class="p">]),</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="s">"Sham"</code><code class="p">,</code><code class="w"> </code><code class="s">"Captain"</code><code class="p">]);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>At this point, the <code>unit_tests</code> module will need all of the following imports:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">use</code><code class="w"> </code><code class="k">super</code>::<code class="p">{</code><code class="n">extract_bytes</code><code class="p">,</code><code class="w"> </code><code class="n">extract_chars</code><code class="p">,</code><code class="w"> </code><code class="n">extract_fields</code><code class="p">,</code><code class="w"> </code><code class="n">parse_pos</code><code class="p">};</code><code class="w"/>
<code class="k">use</code><code class="w"> </code><code class="n">csv</code>::<code class="n">StringRecord</code><code class="p">;</code><code class="w"/></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Once you can pass this last unit test, you should use all of the <code>extract_*</code> functions to print the desired bytes, characters, and fields from the input files. Be sure to run <strong><code>cargo test</code></strong> to see what is and is not working. This is a challenging program, so don’t give up too quickly. Fear is the mind-killer.<a data-primary="cut utility" data-secondary="writing cutr version" data-startref="ix_cutwrprsdeltxt" data-tertiary="parsing delimited text files" data-type="indexterm" id="id1078"/><a data-primary="delimited text files, parsing" data-startref="ix_deltxtfi" data-type="indexterm" id="id1079"/></p>
</div>
</div></section>
</div></section>






<section data-pdf-bookmark="Solution" data-type="sect1"><div class="sect1" id="id205">
<h1>Solution</h1>

<p>I’ll show you my solution now, but I would again stress that there are many ways to write this program.
Any version that passes the test suite is acceptable.
I’ll begin by showing how I evolved <code>extract_chars</code> to select the characters.</p>








<section data-pdf-bookmark="Selecting Characters from a String" data-type="sect2"><div class="sect2" id="id84">
<h2>Selecting Characters from a String</h2>

<p>In this<a data-primary="strings" data-secondary="selecting characters from" data-type="indexterm" id="ix_strselch"/><a data-primary="characters" data-secondary="selecting from a string" data-type="indexterm" id="ix_charsel"/><a data-primary="cut utility" data-secondary="writing cutr version" data-tertiary="selecting characters from a string" data-type="indexterm" id="ix_cutwrselch"/> first version of <code>extract_chars</code>, I initialize a mutable vector to accumulate the results and then use an imperative approach to select the desired characters:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code><code> </code><code class="nf">extract_chars</code><code class="p">(</code><code class="n">line</code><code>:</code><code> </code><code class="kp">&amp;</code><code class="kt">str</code><code class="p">,</code><code class="w"> </code><code class="n">char_pos</code><code>:</code><code> </code><code class="kp">&amp;</code><code class="p">[</code><code class="n">Range</code><code class="o">&lt;</code><code class="kt">usize</code><code class="o">&gt;</code><code class="p">]</code><code class="p">)</code><code class="w"> </code><code>-&gt;</code><code> </code><code class="nb">String</code><code> </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">chars</code><code>:</code><code> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">_</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">line</code><code class="p">.</code><code class="n">chars</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="n">collect</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO18-1" id="co_shave_and_a_haircut_CO18-1"><img alt="1" src="assets/1.png"/></a><code class="w">
    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">selected</code><code>:</code><code> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">char</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[</code><code class="p">]</code><code class="p">;</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO18-2" id="co_shave_and_a_haircut_CO18-2"><img alt="2" src="assets/2.png"/></a><code class="w">

    </code><code class="k">for</code><code class="w"> </code><code class="n">range</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">char_pos</code><code class="p">.</code><code class="n">iter</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="n">cloned</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO18-3" id="co_shave_and_a_haircut_CO18-3"><img alt="3" src="assets/3.png"/></a><code class="w">
        </code><code class="k">for</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">range</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO18-4" id="co_shave_and_a_haircut_CO18-4"><img alt="4" src="assets/4.png"/></a><code class="w">
            </code><code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">val</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">chars</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="n">i</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO18-5" id="co_shave_and_a_haircut_CO18-5"><img alt="5" src="assets/5.png"/></a><code class="w">
                </code><code class="n">selected</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="o">*</code><code class="n">val</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO18-6" id="co_shave_and_a_haircut_CO18-6"><img alt="6" src="assets/6.png"/></a><code class="w">
            </code><code class="p">}</code><code class="w">
</code><code class="w">        </code><code class="p">}</code><code class="w">
</code><code class="w">    </code><code class="p">}</code><code class="w">
</code><code class="w">    </code><code class="n">selected</code><code class="p">.</code><code class="n">iter</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="n">collect</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO18-7" id="co_shave_and_a_haircut_CO18-7"><img alt="7" src="assets/7.png"/></a><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_shave_and_a_haircut_CO18-1" id="callout_shave_and_a_haircut_CO18-1"><img alt="1" src="assets/1.png"/></a></dt>
<dd><p>Use <a href="https://oreil.ly/u9LXa"><code>str::chars</code></a> to split the line of text into characters.<a data-primary="str::chars method" data-type="indexterm" id="id1080"/><a data-primary="Vec type" data-type="indexterm" id="id1081"/> The <code>Vec</code> type annotation is required by Rust because <a href="https://oreil.ly/Xn28H"><code>Iterator::collect</code></a> can return many different types of collections.<a data-primary="Iterator::collect function" data-type="indexterm" id="id1082"/></p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO18-2" id="callout_shave_and_a_haircut_CO18-2"><img alt="2" src="assets/2.png"/></a></dt>
<dd><p>Initialize a mutable vector to hold the selected characters.<a data-primary="ranges" data-secondary="iterating over" data-type="indexterm" id="id1083"/></p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO18-3" id="callout_shave_and_a_haircut_CO18-3"><img alt="3" src="assets/3.png"/></a></dt>
<dd><p>Iterate over each <code>Range</code> of indexes.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO18-4" id="callout_shave_and_a_haircut_CO18-4"><img alt="4" src="assets/4.png"/></a></dt>
<dd><p>Iterate over each value in the <code>Range</code>.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO18-5" id="callout_shave_and_a_haircut_CO18-5"><img alt="5" src="assets/5.png"/></a></dt>
<dd><p>Use <a href="https://oreil.ly/7xsI8"><code>Vec::get</code></a> to select the character at the index.<a data-primary="Vec::get function" data-type="indexterm" id="id1084"/> This might fail if the user has requested positions beyond the end of the string, but a failure to select a character should not generate an error.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO18-6" id="callout_shave_and_a_haircut_CO18-6"><img alt="6" src="assets/6.png"/></a></dt>
<dd><p>If it’s possible to select the character, use <a href="https://oreil.ly/TQlnN"><code>Vec::push</code></a> to add it to the <code>selected</code> characters. Note the use of <code>*</code> to dereference <code>&amp;val</code>.<a data-primary="* (asterisk)" data-secondary="dereference operator" data-type="indexterm" id="id1085"/><a data-primary="Vec::push function" data-type="indexterm" id="id1086"/></p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO18-7" id="callout_shave_and_a_haircut_CO18-7"><img alt="7" src="assets/7.png"/></a></dt>
<dd><p>Use <code>Iterator::collect</code> to create a <code>String</code> from the characters.</p></dd>
</dl>

<p>I can simplify the selection of the characters by using <a href="https://oreil.ly/nZ8Yi"><code>Iterator::filter_map</code></a>, which<a data-primary="Iterator::filter_map function" data-type="indexterm" id="id1087"/> yields only the values for which the supplied closure returns <code>Some(value)</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code><code> </code><code class="nf">extract_chars</code><code class="p">(</code><code class="n">line</code><code>:</code><code> </code><code class="kp">&amp;</code><code class="kt">str</code><code class="p">,</code><code class="w"> </code><code class="n">char_pos</code><code>:</code><code> </code><code class="kp">&amp;</code><code class="p">[</code><code class="n">Range</code><code class="o">&lt;</code><code class="kt">usize</code><code class="o">&gt;</code><code class="p">]</code><code class="p">)</code><code class="w"> </code><code>-&gt;</code><code> </code><code class="nb">String</code><code> </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">chars</code><code>:</code><code> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">_</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">line</code><code class="p">.</code><code class="n">chars</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="n">collect</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">selected</code><code>:</code><code> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">char</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[</code><code class="p">]</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">range</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">char_pos</code><code class="p">.</code><code class="n">iter</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="n">cloned</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">        </code><strong><code class="n">selected</code><code class="p">.</code><code class="n">extend</code><code class="p">(</code><code class="n">range</code><code class="p">.</code><code class="n">filter_map</code><code class="p">(</code><code class="o">|</code><code class="n">i</code><code class="o">|</code><code class="w"> </code><code class="n">chars</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="n">i</code><code class="p">)</code><code class="p">)</code><code class="p">)</code><code class="p">;</code></strong><code class="w">
</code><code class="w">    </code><code class="p">}</code><code class="w">
</code><code class="w">    </code><code class="n">selected</code><code class="p">.</code><code class="n">iter</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="n">collect</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">}</code></pre>

<p>The preceding versions both initialize a variable to collect the results.
In this next version, an <a data-primary="Iterator::map function" data-type="indexterm" id="id1088"/><a data-primary="Iterator::flatten function" data-type="indexterm" id="id1089"/><a data-primary="flatten function (Iterator)" data-type="indexterm" id="id1090"/>iterative approach avoids mutability and leads to a shorter function by using <code>Iterator::map</code> and <code>Iterator::flatten</code>, which, according to <a href="https://oreil.ly/RzXDz">the documentation</a>, “is useful when you have an iterator of iterators or an iterator of things that can be turned into iterators and you want to remove one level of 
<span class="keep-together">indirection”:</span></p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code><code> </code><code class="nf">extract_chars</code><code class="p">(</code><code class="n">line</code><code>:</code><code> </code><code class="kp">&amp;</code><code class="kt">str</code><code class="p">,</code><code class="w"> </code><code class="n">char_pos</code><code>:</code><code> </code><code class="kp">&amp;</code><code class="p">[</code><code class="n">Range</code><code class="o">&lt;</code><code class="kt">usize</code><code class="o">&gt;</code><code class="p">]</code><code class="p">)</code><code class="w"> </code><code>-&gt;</code><code> </code><code class="nb">String</code><code> </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">chars</code><code>:</code><code> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">_</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">line</code><code class="p">.</code><code class="n">chars</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="n">collect</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">    </code><code class="n">char_pos</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">iter</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">cloned</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="w">        </code><strong><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">range</code><code class="o">|</code><code class="w"> </code><code class="n">range</code><code class="p">.</code><code class="n">filter_map</code><code class="p">(</code><code class="o">|</code><code class="n">i</code><code class="o">|</code><code class="w"> </code><code class="n">chars</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="n">i</code><code class="p">)</code><code class="p">)</code><code class="p">)</code></strong><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO19-1" id="co_shave_and_a_haircut_CO19-1"><img alt="1" src="assets/1.png"/></a><code class="w">
        </code><strong><code class="p">.</code><code class="n">flatten</code><code class="p">(</code><code class="p">)</code></strong><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO19-2" id="co_shave_and_a_haircut_CO19-2"><img alt="2" src="assets/2.png"/></a><code class="w">
        </code><code class="p">.</code><code class="n">collect</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_shave_and_a_haircut_CO19-1" id="callout_shave_and_a_haircut_CO19-1"><img alt="1" src="assets/1.png"/></a></dt>
<dd><p>Use <a href="https://oreil.ly/cfevE"><code>Iterator::map</code></a> to process each <code>Range</code> to select the characters.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO19-2" id="callout_shave_and_a_haircut_CO19-2"><img alt="2" src="assets/2.png"/></a></dt>
<dd><p>Use <code>Iterator::flatten</code> to remove nested structures.</p></dd>
</dl>

<p>Without <code>Iterator::flatten</code>, Rust will show the following error:</p>

<pre data-type="programlisting">error[E0277]: a value of type `std::string::String` cannot be built from an
iterator over elements of type `FilterMap&lt;std::ops::Range&lt;usize&gt;</pre>

<p>In the <code>findr</code> program from <a data-type="xref" href="ch07.html#ch07">Chapter 7</a>, I used <code>Iterator::filter_map</code> to combine the operations of <code>filter</code> and <code>map</code>.<a data-primary="Iterator::flat_map function" data-type="indexterm" id="id1091"/><a data-primary="flatten and map operations, combining" data-type="indexterm" id="id1092"/>
Similarly, the operations of <code>flatten</code> and <code>map</code> can be combined with <a href="https://oreil.ly/zHoNC"><code>Iterator::flat_map</code></a> in this shortest and final version of the 
<span class="keep-together">function:</span></p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code><code> </code><code class="nf">extract_chars</code><code class="p">(</code><code class="n">line</code><code>:</code><code> </code><code class="kp">&amp;</code><code class="kt">str</code><code class="p">,</code><code class="w"> </code><code class="n">char_pos</code><code>:</code><code> </code><code class="kp">&amp;</code><code class="p">[</code><code class="n">Range</code><code class="o">&lt;</code><code class="kt">usize</code><code class="o">&gt;</code><code class="p">]</code><code class="p">)</code><code class="w"> </code><code>-&gt;</code><code> </code><code class="nb">String</code><code> </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">chars</code><code>:</code><code> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">_</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">line</code><code class="p">.</code><code class="n">chars</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="n">collect</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">    </code><code class="n">char_pos</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">iter</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">cloned</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="w">        </code><strong><code class="p">.</code><code class="n">flat_map</code><code class="p">(</code><code class="o">|</code><code class="n">range</code><code class="o">|</code><code class="w"> </code><code class="n">range</code><code class="p">.</code><code class="n">filter_map</code><code class="p">(</code><code class="o">|</code><code class="n">i</code><code class="o">|</code><code class="w"> </code><code class="n">chars</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="n">i</code><code class="p">)</code><code class="p">)</code><code class="p">)</code></strong><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">collect</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">}</code></pre>
</div></section>








<section data-pdf-bookmark="Selecting Bytes from a String" data-type="sect2"><div class="sect2" id="id85">
<h2>Selecting Bytes from a String</h2>

<p>The selection of bytes is very similar, but I have <a data-primary="strings" data-secondary="selecting characters from" data-startref="ix_strselch" data-type="indexterm" id="id1093"/><a data-primary="characters" data-secondary="selecting from a string" data-startref="ix_charsel" data-type="indexterm" id="id1094"/><a data-primary="cut utility" data-secondary="writing cutr version" data-startref="ix_cutwrselch" data-tertiary="selecting characters from a string" data-type="indexterm" id="id1095"/>to deal with the fact that <code>String::from_utf8_lossy</code> needs a slice of bytes, unlike the previous example where I could collect an iterator of references to characters into a <code>String</code>.<a data-primary="slices" data-secondary="of bytes" data-secondary-sortas="bytes" data-type="indexterm" id="id1096"/><a data-primary="cut utility" data-secondary="writing cutr version" data-tertiary="selecting bytes from a string" data-type="indexterm" id="id1097"/><a data-primary="bytes" data-secondary="selecting from a string" data-type="indexterm" id="id1098"/><a data-primary="strings" data-secondary="selecting bytes from" data-type="indexterm" id="id1099"/><a data-primary="String::from_utf8_lossy function" data-secondary="needing slice of bytes" data-type="indexterm" id="id1100"/>
As with <code>extract_chars</code>, the goal is to return a new string, but there is a potential problem if the byte selection breaks Unicode characters and so produces <a data-primary="UTF-8 character encoding" data-secondary="byte selection producing invalid UTF-8 string" data-type="indexterm" id="id1101"/>an invalid UTF-8 string:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code><code> </code><code class="nf">extract_bytes</code><code class="p">(</code><code class="n">line</code><code>:</code><code> </code><code class="kp">&amp;</code><code class="kt">str</code><code class="p">,</code><code class="w"> </code><code class="n">byte_pos</code><code>:</code><code> </code><code class="kp">&amp;</code><code class="p">[</code><code class="n">Range</code><code class="o">&lt;</code><code class="kt">usize</code><code class="o">&gt;</code><code class="p">]</code><code class="p">)</code><code class="w"> </code><code>-&gt;</code><code> </code><code class="nb">String</code><code> </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">bytes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">line</code><code class="p">.</code><code class="n">as_bytes</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO20-1" id="co_shave_and_a_haircut_CO20-1"><img alt="1" src="assets/1.png"/></a><code class="w">
    </code><code class="kd">let</code><code class="w"> </code><code class="n">selected</code><code>:</code><code> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">_</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">byte_pos</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">iter</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">cloned</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">flat_map</code><code class="p">(</code><code class="o">|</code><code class="n">range</code><code class="o">|</code><code class="w"> </code><code class="n">range</code><code class="p">.</code><code class="n">filter_map</code><code class="p">(</code><code class="o">|</code><code class="n">i</code><code class="o">|</code><code class="w"> </code><code class="n">bytes</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="n">i</code><code class="p">)</code><code class="p">)</code><code class="p">.</code><code class="n">copied</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO20-2" id="co_shave_and_a_haircut_CO20-2"><img alt="2" src="assets/2.png"/></a><code class="w">
        </code><code class="p">.</code><code class="n">collect</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">    </code><code class="nb">String</code><code>::</code><code class="n">from_utf8_lossy</code><code class="p">(</code><code class="o">&amp;</code><code class="n">selected</code><code class="p">)</code><code class="p">.</code><code class="n">into_owned</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO20-3" id="co_shave_and_a_haircut_CO20-3"><img alt="3" src="assets/3.png"/></a><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_shave_and_a_haircut_CO20-1" id="callout_shave_and_a_haircut_CO20-1"><img alt="1" src="assets/1.png"/></a></dt>
<dd><p>Break the line into a vector of bytes.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO20-2" id="callout_shave_and_a_haircut_CO20-2"><img alt="2" src="assets/2.png"/></a></dt>
<dd><p>Use <code>Iterator::flat_map</code> to select bytes at the wanted positions and copy the selected bytes.<a data-primary="Iterator::flat_map function" data-type="indexterm" id="id1102"/></p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO20-3" id="callout_shave_and_a_haircut_CO20-3"><img alt="3" src="assets/3.png"/></a></dt>
<dd><p>Use <a href="https://oreil.ly/Bs4Zl"><code>String::from_utf8_lossy</code></a> to generate a possibly invalid UTF-8 string from the selected bytes. Use <a href="https://oreil.ly/Jpdd0"><code>Cow::into_owned</code></a> to clone the data, if needed.</p></dd>
</dl>

<p>In the preceding code, I’m using <code>Iterator::get</code> to select the bytes.<a data-primary="Iterator::get function" data-type="indexterm" id="id1103"/><a data-primary="vectors" data-secondary="of byte references" data-secondary-sortas="byte" data-type="indexterm" id="id1104"/>
This function returns a vector of byte references (<code>&amp;Vec&lt;&amp;u8&gt;</code>), but <code>String::from_utf8_lossy</code> expects a slice of bytes (<code>&amp;[u8]</code>).<a data-primary="std::iter::Copied" data-type="indexterm" id="id1105"/>
To fix this, I use <a href="https://oreil.ly/5SvXY"><code>std::iter::Copied</code></a> to create copies of the elements and avoid the following error:</p>

<pre data-type="programlisting">error[E0308]: mismatched types
   --&gt; src/main.rs:159:29
    |
159 |     String::from_utf8_lossy(&amp;selected).into_owned()
    |     ----------------------- ^^^^^^^^^ expected `&amp;[u8]`, found `&amp;Vec&lt;&amp;u8&gt;`
    |     |
    |     arguments to this function are incorrect
    |
    = note: expected reference `&amp;[u8]`
               found reference `&amp;Vec&lt;&amp;u8&gt;`</pre>

<p>Finally, I would note the necessity of using <code>Cow::into_owned</code> at the end of the function.<a data-primary="Cow::into_owned function" data-type="indexterm" id="id1106"/>
Without this, I get a compilation error that suggests an alternate solution to convert <a data-primary="String type" data-secondary="converting Cow value into" data-type="indexterm" id="id1107"/>the <code>Cow</code> value to a <code>String</code>:</p>

<pre data-type="programlisting">error[E0308]: mismatched types
   --&gt; src/main.rs:159:5
    |
152 | fn extract_bytes(line: &amp;str, byte_pos: &amp;[Range&lt;usize&gt;]) -&gt; String {
    |                                                            ------
    |             expected `std::string::String` because of return type
...
159 |     String::from_utf8_lossy(&amp;selected)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion
    |     |                                   method: `.to_string()`
    |     |
    |     expected `String`, found `Cow&lt;'_, str&gt;`
    |
    = note: expected struct `std::string::String`
                 found enum `Cow&lt;'_, str&gt;`</pre>

<p>While the Rust compiler is extremely strict, I appreciate how informative and helpful the error messages are.</p>
</div></section>








<section data-pdf-bookmark="Selecting Fields from a csv::StringRecord" data-type="sect2"><div class="sect2" id="id86">
<h2>Selecting Fields from a csv::StringRecord</h2>

<p>Selecting the fields from a <code>csv::StringRecord</code> is almost identical to extracting<a data-primary="cut utility" data-secondary="writing cutr version" data-tertiary="selecting fields from csv::StringRecord" data-type="indexterm" id="ix_cutwrselfld"/><a data-primary="csv::StringRecord" data-secondary="selecting fields from" data-type="indexterm" id="ix_csvSRselfield"/><a data-primary="fields, selecting from csv::StringRecord" data-type="indexterm" id="ix_fieldsel"/> characters from a line:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code><code> </code><code class="nf">extract_fields</code><code class="p">(</code><code class="w">
</code><code class="w">    </code><code class="n">record</code><code>:</code><code> </code><code class="kp">&amp;</code><code class="nc">StringRecord</code><code class="p">,</code><code class="w">
</code><code class="w">    </code><code class="n">field_pos</code><code>:</code><code> </code><code class="kp">&amp;</code><code class="p">[</code><code class="n">Range</code><code class="o">&lt;</code><code class="kt">usize</code><code class="o">&gt;</code><code class="p">]</code><code class="p">,</code><code class="w">
</code><code class="p">)</code><code class="w"> </code><code>-&gt;</code><code> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="n">field_pos</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">iter</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">cloned</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">flat_map</code><code class="p">(</code><code class="o">|</code><code class="n">range</code><code class="o">|</code><code class="w"> </code><code class="n">range</code><code class="p">.</code><code class="n">filter_map</code><code class="p">(</code><code class="o">|</code><code class="n">i</code><code class="o">|</code><code class="w"> </code><code class="n">record</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="n">i</code><code class="p">)</code><code class="p">)</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO21-1" id="co_shave_and_a_haircut_CO21-1"><img alt="1" src="assets/1.png"/></a><code class="w">
        </code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="nb">String</code><code>::</code><code class="n">from</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO21-2" id="co_shave_and_a_haircut_CO21-2"><img alt="2" src="assets/2.png"/></a><code class="w">
        </code><code class="p">.</code><code class="n">collect</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_shave_and_a_haircut_CO21-1" id="callout_shave_and_a_haircut_CO21-1"><img alt="1" src="assets/1.png"/></a></dt>
<dd><p>Use <a href="https://oreil.ly/pIQuO"><code>StringRecord::get</code></a> to try to get the field for the index position.<a data-primary="StringRecord::get function" data-type="indexterm" id="id1108"/></p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO21-2" id="callout_shave_and_a_haircut_CO21-2"><img alt="2" src="assets/2.png"/></a></dt>
<dd><p>Use <code>Iterator::map</code> to turn <code>&amp;str</code> values into <code>String</code> values.<a data-primary="Iterator::map function" data-secondary="turning &amp;str values into String values" data-type="indexterm" id="id1109"/></p></dd>
</dl>

<p>There’s another way to write this function so that it will return a <code>Vec&lt;&amp;str&gt;</code>, which will be slightly more memory efficient as it will not make copies of the strings.<a data-primary="Vec&lt;&amp;str&gt;" data-type="indexterm" id="id1110"/>
The trade-off is that I must indicate the lifetimes.
First, let me naively try to write it like so:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// This will not compile</code>
<code class="k">fn</code> <code class="nf">extract_fields</code><code class="p">(</code><code class="w"/>
<code class="w">    </code><code class="n">record</code>: <code class="kp">&amp;</code><code class="nc">StringRecord</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="n">field_pos</code>: <code class="kp">&amp;</code><code class="p">[</code><code class="n">Range</code><code class="o">&lt;</code><code class="kt">usize</code><code class="o">&gt;</code><code class="p">],</code><code class="w"/>
<code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Vec</code><code class="o">&lt;&amp;</code><code class="kt">str</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">field_pos</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="n">iter</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="n">cloned</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="n">flat_map</code><code class="p">(</code><code class="o">|</code><code class="n">range</code><code class="o">|</code><code class="w"> </code><code class="n">range</code><code class="p">.</code><code class="n">filter_map</code><code class="p">(</code><code class="o">|</code><code class="n">i</code><code class="o">|</code><code class="w"> </code><code class="n">record</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="n">i</code><code class="p">)))</code><code class="w"/>
<code class="w">        </code><code class="p">.</code><code class="n">collect</code><code class="p">()</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p class="pagebreak-before">If I try to compile this, the Rust <a data-primary="lifetime specifiers for variables" data-type="indexterm" id="id1111"/>compiler will complain about lifetimes:</p>

<pre data-type="programlisting">error[E0106]: missing lifetime specifier
   --&gt; src/main.rs:165:10
    |
163 |     record: &amp;StringRecord,
    |             -------------
164 |     field_pos: &amp;[Range&lt;usize&gt;],
    |                ---------------
165 | ) -&gt; Vec&lt;&amp;str&gt; {
    |          ^ expected named lifetime parameter
    |
    = help: this function's return type contains a borrowed value, but the
    signature does not say whether it is borrowed from `record` or `field_pos`</pre>

<p>The error message continues with directions for how to amend the code to add 
<span class="keep-together">lifetimes:</span></p>

<pre data-type="programlisting">help: consider introducing a named lifetime parameter
    |
162 ~ fn extract_fields&lt;'a&gt;(
163 ~     record: &amp;'a StringRecord,
164 ~     field_pos: &amp;'a [Range&lt;usize&gt;],
165 ~ ) -&gt; Vec&lt;&amp;'a str&gt; {</pre>

<p>The suggestion is actually overconstraining the lifetimes.
The returned string slices refer to values owned by the <code>StringRecord</code>, so only <code>record</code> and the return value need to have the same lifetime.
The following version with lifetimes works well:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code><code> </code><code class="nf">extract_fields</code><strong><code class="o">&lt;</code><code class="o">'</code><code class="na">a</code><code class="o">&gt;</code></strong><code class="p">(</code><code class="w">
</code><code class="w">    </code><code class="n">record</code><code>:</code><code> </code><code class="kp">&amp;</code><strong><code class="o">'</code><code class="na">a</code></strong><code> </code><code class="nc">StringRecord</code><code class="p">,</code><code class="w">
</code><code class="w">    </code><code class="n">field_pos</code><code>:</code><code> </code><code class="kp">&amp;</code><code class="p">[</code><code class="n">Range</code><code class="o">&lt;</code><code class="kt">usize</code><code class="o">&gt;</code><code class="p">]</code><code class="p">,</code><code class="w">
</code><code class="p">)</code><code class="w"> </code><code>-&gt;</code><code> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="o">&amp;</code><strong><code class="o">'</code><code class="na">a</code></strong><code class="w"> </code><code class="kt">str</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="n">field_pos</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">iter</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">cloned</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">flat_map</code><code class="p">(</code><code class="o">|</code><code class="n">range</code><code class="o">|</code><code class="w"> </code><code class="n">range</code><code class="p">.</code><code class="n">filter_map</code><code class="p">(</code><code class="o">|</code><code class="n">i</code><code class="o">|</code><code class="w"> </code><code class="n">record</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="n">i</code><code class="p">)</code><code class="p">)</code><code class="p">)</code><code class="w">
</code><code class="w">        </code><code class="p">.</code><code class="n">collect</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="p">}</code></pre>

<p>Both the version returning <code>Vec&lt;String&gt;</code> and the version returning <code>Vec&lt;&amp;'a str&gt;</code> will pass the <code>test_extract_fields</code> unit test.
The latter version is slightly more efficient and shorter but also has more cognitive overhead.
Choose whichever version you feel you’ll be able to understand six weeks from now.<a data-primary="cut utility" data-secondary="writing cutr version" data-startref="ix_cutwrselfld" data-tertiary="selecting fields from csv::StringRecord" data-type="indexterm" id="id1112"/><a data-primary="csv::StringRecord" data-secondary="selecting fields from" data-startref="ix_csvSRselfield" data-type="indexterm" id="id1113"/><a data-primary="fields, selecting from csv::StringRecord" data-startref="ix_fieldsel" data-type="indexterm" id="id1114"/></p>
</div></section>








<section data-pdf-bookmark="Final Boss" data-type="sect2"><div class="sect2" id="id87">
<h2>Final Boss</h2>

<p>For the following code, be sure to<a data-primary="cut utility" data-secondary="writing cutr version" data-tertiary="final version" data-type="indexterm" id="ix_cutwrfinl"/> add the following imports:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">use</code><code class="w"> </code><code class="n">csv</code>::<code class="p">{</code><code class="n">ReaderBuilder</code><code class="p">,</code><code class="w"> </code><code class="n">StringRecord</code><code class="p">,</code><code class="w"> </code><code class="n">WriterBuilder</code><code class="p">};</code><code class="w"/></pre>

<p>Here is my <code>run</code> function that passes <a data-primary="run function" data-secondary="cutr utility" data-type="indexterm" id="id1115"/>all the tests for printing the desired ranges of characters, bytes, and records:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code><code> </code><code class="nf">run</code><code class="p">(</code><code class="n">args</code><code>:</code><code> </code><code class="nc">Args</code><code class="p">)</code><code class="w"> </code><code>-&gt;</code><code> </code><code class="nb">Result</code><code class="o">&lt;</code><code class="p">(</code><code class="p">)</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">delim_bytes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">args</code><code class="p">.</code><code class="n">delimiter</code><code class="p">.</code><code class="n">as_bytes</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">delim_bytes</code><code class="p">.</code><code class="n">len</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">!</code><code class="o">=</code><code class="w"> </code><code class="mi">1</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">        </code><code class="n">bail</code><code class="o">!</code><code class="p">(</code><code class="s">r#"--delim "{}" must be a single byte"#</code><code class="p">,</code><code class="w"> </code><code class="n">args</code><code class="p">.</code><code class="n">delimiter</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">    </code><code class="p">}</code><code class="w">
</code><code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">delimiter</code><code>:</code><code> </code><code class="kt">u8</code><code> </code><code class="o">=</code><code class="w"> </code><code class="o">*</code><code class="n">delim_bytes</code><code class="p">.</code><code class="n">first</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="n">unwrap</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">extract</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">fields</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w">
</code><code class="w">        </code><code class="n">args</code><code class="p">.</code><code class="n">extract</code><code class="p">.</code><code class="n">fields</code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="n">parse_pos</code><code class="p">)</code><code class="p">.</code><code class="n">transpose</code><code class="p">(</code><code class="p">)</code><code class="o">?</code><code class="w">
</code><code class="w">    </code><code class="p">{</code><code class="w">
</code><code class="w">        </code><code class="n">Extract</code><code>::</code><code class="n">Fields</code><code class="p">(</code><code class="n">fields</code><code class="p">)</code><code class="w">
</code><code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">bytes</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w">
</code><code class="w">        </code><code class="n">args</code><code class="p">.</code><code class="n">extract</code><code class="p">.</code><code class="n">bytes</code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="n">parse_pos</code><code class="p">)</code><code class="p">.</code><code class="n">transpose</code><code class="p">(</code><code class="p">)</code><code class="o">?</code><code class="w">
</code><code class="w">    </code><code class="p">{</code><code class="w">
</code><code class="w">        </code><code class="n">Extract</code><code>::</code><code class="n">Bytes</code><code class="p">(</code><code class="n">bytes</code><code class="p">)</code><code class="w">
</code><code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">chars</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w">
</code><code class="w">        </code><code class="n">args</code><code class="p">.</code><code class="n">extract</code><code class="p">.</code><code class="n">chars</code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="n">parse_pos</code><code class="p">)</code><code class="p">.</code><code class="n">transpose</code><code class="p">(</code><code class="p">)</code><code class="o">?</code><code class="w">
</code><code class="w">    </code><code class="p">{</code><code class="w">
</code><code class="w">        </code><code class="n">Extract</code><code>::</code><code class="n">Chars</code><code class="p">(</code><code class="n">chars</code><code class="p">)</code><code class="w">
</code><code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">        </code><code class="fm">unreachable!</code><code class="p">(</code><code class="s">"</code><code class="s">Must have --fields, --bytes, or --chars</code><code class="s">"</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">    </code><code class="p">}</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">filename</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="o">&amp;</code><code class="n">args</code><code class="p">.</code><code class="n">files</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">        </code><code class="k">match</code><code class="w"> </code><code class="n">open</code><code class="p">(</code><code class="n">filename</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">            </code><code class="nb">Err</code><code class="p">(</code><code class="n">err</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="o">&gt;</code><code class="w"> </code><code class="fm">eprintln!</code><code class="p">(</code><code class="s">"</code><code class="s">{filename}: {err}</code><code class="s">"</code><code class="p">)</code><code class="p">,</code><code class="w">
</code><code class="w">            </code><code class="nb">Ok</code><code class="p">(</code><code class="n">file</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="o">&gt;</code><code class="w"> </code><code class="k">match</code><code class="w"> </code><code class="o">&amp;</code><code class="n">extract</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">                </code><code class="n">Extract</code><code>::</code><code class="n">Fields</code><code class="p">(</code><code class="n">field_pos</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">                    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">reader</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">ReaderBuilder</code><code>::</code><code class="n">new</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO22-1" id="co_shave_and_a_haircut_CO22-1"><img alt="1" src="assets/1.png"/></a><code class="w">
                        </code><code class="p">.</code><code class="n">delimiter</code><code class="p">(</code><code class="n">delimiter</code><code class="p">)</code><code class="w">
</code><code class="w">                        </code><code class="p">.</code><code class="n">has_headers</code><code class="p">(</code><code class="kc">false</code><code class="p">)</code><code class="w">
</code><code class="w">                        </code><code class="p">.</code><code class="n">from_reader</code><code class="p">(</code><code class="n">file</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">                    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">wtr</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">WriterBuilder</code><code>::</code><code class="n">new</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO22-2" id="co_shave_and_a_haircut_CO22-2"><img alt="2" src="assets/2.png"/></a><code class="w">
                        </code><code class="p">.</code><code class="n">delimiter</code><code class="p">(</code><code class="n">delimiter</code><code class="p">)</code><code class="w">
</code><code class="w">                        </code><code class="p">.</code><code class="n">from_writer</code><code class="p">(</code><code class="n">io</code><code>::</code><code class="n">stdout</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">
</code><code class="w">                    </code><code class="k">for</code><code class="w"> </code><code class="n">record</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">reader</code><code class="p">.</code><code class="n">records</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO22-3" id="co_shave_and_a_haircut_CO22-3"><img alt="3" src="assets/3.png"/></a><code class="w">
                        </code><code class="n">wtr</code><code class="p">.</code><code class="n">write_record</code><code class="p">(</code><code class="n">extract_fields</code><code class="p">(</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO22-4" id="co_shave_and_a_haircut_CO22-4"><img alt="4" src="assets/4.png"/></a><code class="w">
                            </code><code class="o">&amp;</code><code class="n">record</code><code class="o">?</code><code class="p">,</code><code class="w"> </code><code class="n">field_pos</code><code class="p">,</code><code class="w">
</code><code class="w">                        </code><code class="p">)</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w">
</code><code class="w">                    </code><code class="p">}</code><code class="w">
</code><code class="w">                </code><code class="p">}</code><code class="w">
</code><code class="w">                </code><code class="n">Extract</code><code>::</code><code class="n">Bytes</code><code class="p">(</code><code class="n">byte_pos</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">                    </code><code class="k">for</code><code class="w"> </code><code class="n">line</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">file</code><code class="p">.</code><code class="n">lines</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO22-5" id="co_shave_and_a_haircut_CO22-5"><img alt="5" src="assets/5.png"/></a><code class="w">
                        </code><code class="fm">println!</code><code class="p">(</code><code class="s">"</code><code class="s">{}</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">extract_bytes</code><code class="p">(</code><code class="o">&amp;</code><code class="n">line</code><code class="o">?</code><code class="p">,</code><code class="w"> </code><code class="n">byte_pos</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">                    </code><code class="p">}</code><code class="w">
</code><code class="w">                </code><code class="p">}</code><code class="w">
</code><code class="w">                </code><code class="n">Extract</code><code>::</code><code class="n">Chars</code><code class="p">(</code><code class="n">char_pos</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">                    </code><code class="k">for</code><code class="w"> </code><code class="n">line</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">file</code><code class="p">.</code><code class="n">lines</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><a class="co" href="#callout_shave_and_a_haircut_CO22-6" id="co_shave_and_a_haircut_CO22-6"><img alt="6" src="assets/6.png"/></a><code class="w">
                        </code><code class="fm">println!</code><code class="p">(</code><code class="s">"</code><code class="s">{}</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">extract_chars</code><code class="p">(</code><code class="o">&amp;</code><code class="n">line</code><code class="o">?</code><code class="p">,</code><code class="w"> </code><code class="n">char_pos</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="w">
</code><code class="w">                    </code><code class="p">}</code><code class="w">
</code><code class="w">                </code><code class="p">}</code><code class="w">
</code><code class="w">            </code><code class="p">}</code><code class="p">,</code><code class="w">
</code><code class="w">        </code><code class="p">}</code><code class="w">
</code><code class="w">    </code><code class="p">}</code><code class="w">
</code><code class="w">    </code><code class="nb">Ok</code><code class="p">(</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_shave_and_a_haircut_CO22-1" id="callout_shave_and_a_haircut_CO22-1"><img alt="1" src="assets/1.png"/></a></dt>
<dd><p>If the user has requested fields from a delimited file, use <code>csv::ReaderBuilder</code> to create a mutable reader using the given delimiter, and do not treat the first row as headers.<a data-primary="csv::ReaderBuilder" data-type="indexterm" id="id1116"/><a data-primary="csv::WriterBuilder" data-type="indexterm" id="id1117"/></p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO22-2" id="callout_shave_and_a_haircut_CO22-2"><img alt="2" src="assets/2.png"/></a></dt>
<dd><p>Use <code>csv::WriterBuilder</code> to correctly escape delimiters in the output.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO22-3" id="callout_shave_and_a_haircut_CO22-3"><img alt="3" src="assets/3.png"/></a></dt>
<dd><p>Iterate through the records.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO22-4" id="callout_shave_and_a_haircut_CO22-4"><img alt="4" src="assets/4.png"/></a></dt>
<dd><p>Write the extracted fields to the output.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO22-5" id="callout_shave_and_a_haircut_CO22-5"><img alt="5" src="assets/5.png"/></a></dt>
<dd><p>Iterate the lines of text and print the extracted bytes.</p></dd>
<dt><a class="co" href="#co_shave_and_a_haircut_CO22-6" id="callout_shave_and_a_haircut_CO22-6"><img alt="6" src="assets/6.png"/></a></dt>
<dd><p>Iterate the lines of text and print the extracted characters.</p></dd>
</dl>

<p>The <code>csv::Reader</code> will attempt to parse the first row for the column names by default.<a data-primary="csv::Reader" data-type="indexterm" id="id1118"/>
For this program, I don’t need to do anything special with these values, so I don’t parse the first line as a header row.
If I used the default behavior, I would have to handle the headers separately from the rest of the records.<a data-primary="delimiters" data-secondary="escaping in cutr utility" data-type="indexterm" id="id1119"/></p>

<p>Note that I’m using the <code>csv</code> crate to both parse the input and write the output, so this program will correctly handle delimited text files, which I feel is an improvement over the original <code>cut</code> programs.
I’ll use <em>tests/inputs/books.csv</em> again to demonstrate that <code>cutr</code> will correctly select a field containing the delimiter and will create output that properly escapes the delimiter and puts the columns in the requested order:</p>

<pre data-type="programlisting">$ cargo run -- -d , -f 3,1 tests/inputs/books.csv
Title,Author
La Confession de Claude,Émile Zola
Waiting for Godot,Samuel Beckett
"20,000 Leagues Under the Sea",Jules Verne</pre>

<p>This was a fairly complex program with a lot of options, but I found the strictness of the Rust compiler kept me focused on how to write a solution.<a data-primary="cut utility" data-secondary="writing cutr version" data-startref="ix_cutwrfinl" data-tertiary="final version" data-type="indexterm" id="id1120"/></p>
</div></section>
</div></section>






<section data-pdf-bookmark="Going Further" data-type="sect1"><div class="sect1" id="id151">
<h1>Going Further</h1>

<p>I have several ideas for how you can expand this program.
Alter the program to allow partial ranges like <code>-3</code>, meaning <em>1–3</em>, or <code>5-</code> to mean <em>5 to the end</em>.<a data-primary="cut utility" data-secondary="writing cutr version" data-tertiary="going further" data-type="indexterm" id="id1121"/><a data-primary="ranges" data-secondary="partial, altering cutr to allow" data-type="indexterm" id="id1122"/>
Consider using <a href="https://oreil.ly/ZniC2"><code>std::ops::RangeTo</code></a> to model <code>-3</code> and <a href="https://oreil.ly/azzZY"><code>std::ops::RangeFrom</code></a> for <code>5-</code>.
Be aware that <code>clap</code> will try to interpret the value <code>-3</code> as an option when you run <strong><code>cargo run -- -f -3 tests/inputs/books.tsv</code></strong>, so use 
<span class="keep-together"><code>-f=-3</code></span> instead.</p>

<p>The final version of the challenge program uses the <code>--delimiter</code> as the input and output delimiter.
Add an option to specify the output delimiter, and have it default to the input delimiter.</p>

<p>The <code>-n</code> option that will prevent the splitting of multibyte characters seems like a fun challenge to implement, and I also quite like the <code>--complement</code> option from GNU <code>cut</code> that complements the set of selected bytes, characters, or fields so that the positions <em>not</em> indicated are shown.
Finally, for more ideas on how to deal with delimited text records, check out the <a href="https://oreil.ly/894fA"><code>xsv</code> crate</a>, a “fast CSV command line toolkit written in Rust” and <a href="https://crates.io/crates/csvchk"><code>csvchk</code></a> to see a vertical view of delimited text records.</p>
</div></section>






<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="id88">
<h1>Summary</h1>

<p>Gaze upon the knowledge you gained in this chapter:</p>
<ul class="widows_6">
<li>
<p>You learned how to dereference a variable that contains a reference using the
<span class="keep-together"><code>*</code> operator.</span></p>
</li>
<li>
<p>Sometimes actions on iterators return other iterators. You saw how <code>Iterator​::flatten</code> will remove the inner structures to flatten the result.</p>
</li>
<li>
<p>You learned how the <code>Iterator::flat_map</code> method combines <code>Iterator::map</code> and <code>Iterator::flatten</code> into one operation for more concise code.</p>
</li>
<li>
<p>You used a <code>get</code> function for selecting positions from a vector or fields from a <code>csv::StringRecord</code>. This action might fail, so you used <code>Iterator::filter_map</code> to return only those values that are successfully retrieved.</p>
</li>
<li>
<p>You compared how to return a <code>String</code> versus a <code>&amp;str</code> from a function, the latter of which required indicating lifetimes.</p>
</li>
<li>
<p>You can now parse and create delimited text using the <code>csv</code> crate.<a data-primary="cut utility" data-startref="ix_cut" data-type="indexterm" id="id-OauES3h9cgf9to"/></p>
</li>
</ul>

<p>In the next chapter, you will learn more about regular expressions and chaining operations on iterators.</p>
</div></section>
</div></section></body></html>